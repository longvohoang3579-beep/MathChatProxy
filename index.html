<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Assistant Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* --- Gi·ªØ nguy√™n to√†n b·ªô CSS c·ªßa b·∫°n --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        :root { --primary-yellow: #facc15; --dark-bg: #0a0a0c; /* ... */ }
        body { font-family: 'Inter', sans-serif; /* ... */ }
        .summary-actions { margin-top: 10px; display: flex; gap: 10px; }
        .summary-btn { background-color: #444; color: #eee; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; cursor: pointer; }
    </style>
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
</head>
<body>
    <audio id="intro-audio" src="data:audio/mpeg;base64,..."></audio>
    <div id="intro-screen">...</div>
    <div id="limit-overlay">...</div>
    <div id="voice-overlay">...</div>

    <div id="app-wrapper">
        <aside id="sidebar">...</aside>
        <main id="chat-container">
            <div class="header relative">...</div>
            <div class="chat-box" id="chatBox"></div>
            <div class="input-area">
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="chat" title="Tr√≤ chuy·ªán"><span>Chat</span></button>
                    <button class="mode-btn" data-mode="image" title="T·∫°o ·∫£nh"><span>T·∫°o ·∫¢nh</span></button>
                    <button class="mode-btn" data-mode="math" title="Gi·∫£i to√°n"><span>Gi·∫£i To√°n</span></button>
                    <button class="mode-btn" data-mode="video" title="T·∫°o video"><span>T·∫°o Video</span></button>
                    <button class="mode-btn" data-mode="edit_image" title="Ch·ªânh s·ª≠a ·∫£nh"><span>S·ª≠a ·∫¢nh</span></button>
                    <button class="mode-btn" data-mode="summarize_youtube" title="T√≥m t·∫Øt YouTube"><span>T√≥m T·∫Øt YT</span></button>
                    <button class="mode-btn" data-mode="notetaker" title="Ghi ch√∫ vƒÉn b·∫£n"><span>Ghi Ch√∫</span></button>
                </div>
                <div class="pending-preview" id="previewContainer"></div>
                <div class="input-row">...</div>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Gi·ªØ nguy√™n c√°c bi·∫øn DOM v√† logic c≈© ---
        const getEl = (id) => document.getElementById(id);
        const introScreen = getEl('intro-screen'), /*...*/ passwordMessage = getEl('password-message');
        const modeButtons = document.querySelectorAll('.mode-btn');

        let currentChatMode = 'chat', uploadedFile = null, chatHistory = {}, activeChatId = null, isRecording = false;

        // === Logic Gi·ªõi H·∫°n H√†ng Ng√†y ===
        const MAX_DAILY_USES = 20;
        const UNLOCK_PASSWORD = "Hoang1082009@";
        let usageData = { count: 0, date: '', unlocked: false };

        function loadUsageData() {
            const storedData = JSON.parse(localStorage.getItem('ai_pro_usage_v2')) || { count: 0, date: '', unlocked: false };
            const today = new Date().toLocaleDateString(); // L·∫•y ng√†y h√¥m nay d·∫°ng 'MM/DD/YYYY' ho·∫∑c t∆∞∆°ng t·ª±

            // Reset n·∫øu sang ng√†y m·ªõi ho·∫∑c ch∆∞a t·ª´ng d√πng
            if (storedData.date !== today && !storedData.unlocked) {
                usageData = { count: 0, date: today, unlocked: false };
            } else {
                usageData = storedData;
            }
            // ƒê·∫£m b·∫£o date ƒë∆∞·ª£c c·∫≠p nh·∫≠t n·∫øu ƒë√£ unlock
            if (usageData.unlocked) usageData.date = today;

            saveUsageData(); // L∆∞u l·∫°i tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t (ƒë·∫∑c bi·ªát l√† date)
            checkUsageLimit();
        }

        function saveUsageData() {
            localStorage.setItem('ai_pro_usage_v2', JSON.stringify(usageData));
            updateUsageDisplay(); // C·∫≠p nh·∫≠t hi·ªÉn th·ªã tr√™n sidebar (n·∫øu c√≥)
        }
         function updateUsageDisplay() {
            const counterEl = document.getElementById('usage-counter'); // Gi·∫£ s·ª≠ b·∫°n c√≥ element n√†y
            if (!counterEl) return;
            if (usageData.unlocked) {
                counterEl.textContent = "Unlocked: Unlimited";
            } else {
                counterEl.textContent = `H√¥m nay: ${usageData.count} / ${MAX_DAILY_USES}`;
            }
         }


        function checkUsageLimit() {
            const isLocked = !usageData.unlocked && usageData.count >= MAX_DAILY_USES;
            limitOverlay.style.display = isLocked ? 'flex' : 'none';
            // Disable/enable inputs and buttons
            [mainInput, sendBtn, voiceBtn, fileInput].forEach(el => el.disabled = isLocked);
            modeButtons.forEach(btn => btn.disabled = isLocked);
             // Visual indication
            [voiceBtn, sendBtn, fileInput.labels[0]].forEach(btn => { if(btn) btn.style.cssText = isLocked ? 'opacity: 0.5; cursor: not-allowed;' : ''; });
            modeButtons.forEach(btn => btn.style.cssText = isLocked ? 'opacity: 0.5; cursor: not-allowed;' : '');
            return !isLocked;
        }

        function incrementUsageCount() {
            if (!usageData.unlocked) {
                usageData.count++;
                saveUsageData(); // Save updated count and today's date
                checkUsageLimit();
            }
        }

        unlockBtn.addEventListener('click', () => {
            if (passwordInput.value === UNLOCK_PASSWORD) {
                usageData.unlocked = true;
                usageData.date = new Date().toLocaleDateString(); // C·∫≠p nh·∫≠t ng√†y khi unlock
                saveUsageData(); // L∆∞u tr·∫°ng th√°i ƒë√£ unlock
                passwordMessage.textContent = 'M·ªü kh√≥a th√†nh c√¥ng!';
                passwordMessage.className = 'mt-3 text-green-500';
                setTimeout(() => checkUsageLimit(), 1500);
            } else { /* ... x·ª≠ l√Ω sai m·∫≠t kh·∫©u ... */ }
        });

        // === Logic Voice Chat (N√¢ng c·∫•p) ===
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let stopRecognitionTimeout; // ƒê·ªÉ t·ª± ƒë·ªông d·ª´ng n·∫øu im l·∫∑ng
        let conversationMode = false; // Tr·∫°ng th√°i ƒëang n√≥i chuy·ªán li√™n t·ª•c

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false; // Nh·∫≠n d·∫°ng t·ª´ng c√¢u
            recognition.interimResults = false;

            recognition.onstart = () => { /* ... gi·ªØ nguy√™n ... */ };
            recognition.onresult = (event) => {
                clearTimeout(stopRecognitionTimeout); // H·ªßy timeout n·∫øu c√≥ k·∫øt qu·∫£
                const transcript = event.results[0][0].transcript;
                handleVoiceQuery(transcript, recognition.lang); // G·ª≠i ƒëi x·ª≠ l√Ω
            };
            recognition.onend = () => {
                isRecording = false;
                micWave.classList.remove('listening');
                voiceMicIcon.textContent = 'üé§';
                // N·∫øu ƒëang trong ch·∫ø ƒë·ªô tr√≤ chuy·ªán v√† AI kh√¥ng n√≥i, t·ª± ƒë·ªông l·∫Øng nghe l·∫°i
                if (conversationMode && !speechSynthesis.speaking) {
                    startListening(); // G·ªçi h√†m l·∫Øng nghe l·∫°i
                } else if (!conversationMode){
                     voiceStatus.textContent = "Nh·∫•n Mic ƒë·ªÉ B·∫Øt ƒë·∫ßu N√≥i...";
                }
            };
            recognition.onerror = (event) => { /* ... gi·ªØ nguy√™n x·ª≠ l√Ω l·ªói ... */ };
        } else { voiceBtn.style.display = 'none'; }

        function startListening() {
            if (!recognition || isRecording) return;
            const langMap = {'vi': 'vi-VN', 'en': 'en-US', 'zh-CN': 'zh-CN'};
            recognition.lang = langMap[languageSelect.value] || 'vi-VN';
            try {
                recognition.start();
                // T·ª± ƒë·ªông d·ª´ng n·∫øu im l·∫∑ng qu√° 5 gi√¢y
                stopRecognitionTimeout = setTimeout(() => {
                    if (isRecording) recognition.stop();
                }, 5000);
            } catch(e) { /* ... x·ª≠ l√Ω l·ªói start ... */ }
        }

        async function handleVoiceQuery(transcript, langCode) {
            voiceStatus.textContent = "AI ƒêang X·ª≠ L√Ω...";
            try {
                const shortLang = langCode.split('-')[0];
                const responseData = await callApi('/api/chat', { message: transcript, image: null, language: shortLang });
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = responseData.response;
                const aiReplyText = tempDiv.textContent || tempDiv.innerText || "";

                if (!aiReplyText || aiReplyText.startsWith('‚ùå')) throw new Error(aiReplyText || "AI response invalid.");

                await speak(aiReplyText, langCode); // AI n√≥i xong

                // T·ª± ƒë·ªông l·∫Øng nghe l·∫°i n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô tr√≤ chuy·ªán
                if (conversationMode) {
                     startListening();
                } else {
                     voiceOverlay.style.display = 'none'; // ƒê√≥ng overlay n·∫øu kh√¥ng ph·∫£i conversation mode
                }

            } catch (error) { /* ... x·ª≠ l√Ω l·ªói v√† ƒë·ªçc l·ªói ... */
                 await speak(errorMessageToSpeak, langCode);
                 // ƒê√≥ng overlay n·∫øu c√≥ l·ªói nghi√™m tr·ªçng
                 setTimeout(() => voiceOverlay.style.display = 'none', 1000);
            }
            incrementUsageCount();
        }

        voiceBtn.addEventListener('click', () => { /* ... gi·ªØ nguy√™n ... */
            conversationMode = true; // B·∫≠t ch·∫ø ƒë·ªô tr√≤ chuy·ªán khi m·ªü overlay
            voiceOverlay.style.display = 'flex';
            startListening(); // B·∫Øt ƒë·∫ßu l·∫Øng nghe ngay khi m·ªü
        });

        voiceMicIcon.addEventListener('click', () => { // N√∫t n√†y gi·ªù ch·ªâ ƒë·ªÉ d·ª´ng/b·∫Øt ƒë·∫ßu n√≥i
            if (!recognition) return;
            if (isRecording) {
                recognition.stop();
                 clearTimeout(stopRecognitionTimeout);
            } else {
                 startListening();
            }
        });

        voiceCloseBtn.addEventListener('click', () => { // N√∫t ƒë√≥ng s·∫Ω t·∫Øt h·∫≥n ch·∫ø ƒë·ªô tr√≤ chuy·ªán
            conversationMode = false; // T·∫Øt ch·∫ø ƒë·ªô tr√≤ chuy·ªán
            if(isRecording) recognition.stop();
            speechSynthesis.cancel();
            clearTimeout(stopRecognitionTimeout);
            voiceOverlay.style.display = 'none';
        });

        // === Logic Flashcard/Mindmap ===
        function addSummaryActions(bubbleElement, summaryText) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'summary-actions';
            actionsDiv.innerHTML = `
                <button class="summary-btn" data-action="flashcard">T·∫°o Flashcards</button>
                <button class="summary-btn" data-action="mindmap">T·∫°o Mindmap</button>
            `;
            actionsDiv.querySelectorAll('.summary-btn').forEach(button => {
                button.addEventListener('click', async () => {
                    const action = button.dataset.action;
                    const endpoint = action === 'flashcard' ? '/api/generate-flashcards' : '/api/generate-mindmap';
                    button.textContent = 'ƒêang t·∫°o...';
                    button.disabled = true;
                    try {
                        const response = await callApi(endpoint, { textToConvert: summaryText });
                        // Hi·ªÉn th·ªã k·∫øt qu·∫£ trong bubble m·ªõi
                        appendMessage(response.response, 'ai');
                        incrementUsageCount(); // T√≠nh l∆∞·ª£t
                    } catch (error) {
                        appendMessage(`‚ùå L·ªói t·∫°o ${action}: ${error.message}`, 'ai');
                    } finally {
                        button.textContent = action === 'flashcard' ? 'T·∫°o Flashcards' : 'T·∫°o Mindmap';
                        button.disabled = false;
                    }
                });
            });
            bubbleElement.appendChild(actionsDiv);
        }


        // === H√†m G·ª≠i Ch√≠nh (C·∫≠p nh·∫≠t) ===
        const handleSendMessage = async () => {
            // ... (Gi·ªØ nguy√™n ph·∫ßn ki·ªÉm tra limit, l·∫•y prompt, image) ...
             if (!checkUsageLimit()) return;
             const prompt = mainInput.value.trim();
             const image = uploadedFile;
             if (currentChatMode === 'edit_image' && !image) { alert("Vui l√≤ng t·∫£i ·∫£nh l√™n."); return; }
             if (!prompt && !image) { return; } // Cho ph√©p g·ª≠i ·∫£nh kh√¥ng c·∫ßn text ·ªü ch·∫ø ƒë·ªô chat/math

             // ... (Gi·ªØ nguy√™n ph·∫ßn hi·ªÉn th·ªã user message, update title) ...
             appendMessage(userMessageContent, 'user');
             updateChatTitle(prompt, !prompt && !!image);
             const loadingBubble = showLoading();
             const currentPromptValue = prompt; const currentImageValue = image;
             mainInput.value = ''; previewContainer.innerHTML = ''; uploadedFile = null; fileInput.value = ''; mainInput.style.height = 'auto';

            try {
                let responseData;
                let finalContent = '';
                let isSummary = false; // C·ªù ƒë·ªÉ bi·∫øt c√≥ c·∫ßn th√™m n√∫t flashcard/mindmap kh√¥ng

                switch (currentChatMode) {
                    // ... (Gi·ªØ nguy√™n case 'image', 'video', 'math') ...
                    case 'edit_image':
                        loadingBubble.querySelector('.bubble').innerHTML = 'Generating edit description...';
                        const descriptionResponse = await callApi('/api/edit-image', { message: currentPromptValue, image: currentImageValue });
                        const newPrompt = descriptionResponse.response;
                        if (newPrompt.startsWith('‚ùå')) throw new Error(newPrompt);
                        loadingBubble.querySelector('.bubble').innerHTML = 'Generating edited image...';
                        const imageResponse = await callApi('/api/pollinations-image', { prompt: newPrompt });
                        finalContent = `<p><strong>Generated prompt:</strong> ${newPrompt}</p><img src="${imageResponse.imageUrl}" class="generated-image">`;
                        break;
                    case 'summarize_youtube':
                        responseData = await callApi('/api/summarize-youtube', { youtubeUrl: currentPromptValue });
                        finalContent = responseData.response;
                        isSummary = true; // ƒê√°nh d·∫•u ƒë√¢y l√† t√≥m t·∫Øt
                        break;
                    case 'notetaker':
                        responseData = await callApi('/api/summarize-text', { textToSummarize: currentPromptValue });
                        finalContent = responseData.response;
                        isSummary = true; // ƒê√°nh d·∫•u ƒë√¢y l√† t√≥m t·∫Øt
                        break;
                    default: // Chat
                        responseData = await callApi('/api/chat', { message: currentPromptValue, image: currentImageValue, language: languageSelect.value });
                        finalContent = responseData.response;
                        break;
                }

                const bubbleElement = loadingBubble.querySelector('.bubble');
                if (currentChatMode !== 'math') { // MathJax x·ª≠ l√Ω ri√™ng
                    bubbleElement.innerHTML = finalContent;
                }

                // Th√™m n√∫t Flashcard/Mindmap n·∫øu l√† k·∫øt qu·∫£ t√≥m t·∫Øt
                if (isSummary && !finalContent.startsWith('‚ùå')) {
                    addSummaryActions(bubbleElement, finalContent);
                }

                saveMessage(bubbleElement.innerHTML, 'ai');
                incrementUsageCount();
            } catch (error) { /* ... gi·ªØ nguy√™n x·ª≠ l√Ω l·ªói ... */ }
        };

        // --- Gi·ªØ nguy√™n c√°c h√†m v√† listener kh√°c ---
        // (playIntro, save/load history, start/load chat, render history, appendMessage, showLoading, callApi, createGif, etc.)
         sendBtn.addEventListener('click', handleSendMessage);
         mainInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
         // ... (C√°c h√†m helper kh√°c gi·ªØ nguy√™n) ...

        // --- Kh·ªüi t·∫°o ---
        function initializeApp() {
            playIntro();
            loadHistoryFromStorage();
            if (Object.keys(chatHistory).length === 0) startNewChat();
            else loadChat(Object.keys(chatHistory).sort().pop());
            renderChatHistory();
            loadUsageData(); // D√πng h√†m m·ªõi ƒë·ªÉ load v√† ki·ªÉm tra limit h√†ng ng√†y
            document.querySelector('.mode-btn[data-mode="chat"]')?.click();
        }
        initializeApp();
    });
    </script>
</body>
</html>