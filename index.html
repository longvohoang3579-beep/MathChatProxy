<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Assistant Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true });</script>
    <style>
        /* --- Giữ nguyên toàn bộ CSS từ file doc --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        :root { --primary-yellow: #facc15; --dark-bg: #0a0a0c; --main-bg: #141417; --input-bg: #1f1f23; --bubble-ai-bg: #2d2d33; --bubble-user-bg: linear-gradient(135deg, #5e5ce6, #2563eb); --text-primary: #e4e4e7; --text-secondary: #a1a1aa; }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: var(--main-bg); } ::-webkit-scrollbar-thumb { background-color: #4a4a52; border-radius: 10px; border: 2px solid var(--main-bg); }
        body { background-color: var(--dark-bg); background-image: radial-gradient(circle at 1% 1%, rgba(255, 255, 255, 0.04) 1px, transparent 0), radial-gradient(circle at 99% 99%, rgba(255, 255, 255, 0.04) 1px, transparent 0); background-size: 50px 50px; color: var(--text-primary); font-family: 'Inter', sans-serif; margin: 0; padding: 0; overflow: hidden; }
        #intro-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: var(--dark-bg); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 1; transition: opacity 1s ease-in-out 6s; }
        .intro-container { position: relative; display: flex; align-items: center; justify-content: center; }
        #intro-yellow-flash { position: absolute; width: 100vw; height: 100vh; background-color: var(--primary-yellow); animation: yellowFlash 2s ease-in-out forwards; } @keyframes yellowFlash { 0% { transform: scale(0); border-radius: 50%; } 50% { transform: scale(1); border-radius: 0; } 100% { transform: scale(1); border-radius: 0; opacity: 0; } }
        #intro-text { position: relative; color: #fff; font-size: 3rem; font-weight: bold; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); opacity: 0; animation: logoAnimate 4s ease-in-out 1.5s forwards; }
        #intro-text::after { content: ''; position: absolute; top: 0; left: -10%; width: 20%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent); transform: skewX(-25deg); opacity: 0; animation: shine 1.5s ease-in-out 3s forwards; }
        #intro-burst { position: absolute; width: 1px; height: 1px; background: white; border-radius: 50%; opacity: 0; animation: burst 1s ease-out 5s forwards; } @keyframes logoAnimate { 0% { opacity: 0; transform: scale(2); } 25% { opacity: 1; transform: scale(1); } 75% { opacity: 1; transform: scale(1); } 100% { opacity: 1; transform: scale(1.1); } } @keyframes shine { 0% { left: -10%; opacity: 1; } 100% { left: 110%; opacity: 1; } } @keyframes burst { from { opacity: 1; transform: scale(0); box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px var(--primary-yellow), 0 0 30px var(--primary-yellow); } to { opacity: 0; transform: scale(200); box-shadow: 0 0 50px #fff, 0 0 75px var(--primary-yellow); } }
        #app-wrapper { display: flex; height: 100vh; opacity: 0; transition: opacity 0.5s ease-in; position: relative; z-index: 1; }
        mark.highlight { background-color: var(--primary-yellow); color: black; font-weight: bold; padding: 2px 5px; border-radius: 4px; }
        #sidebar { width: 260px; background-color: var(--dark-bg); border-right: 1px solid #27272a; padding: 1rem; display: flex; flex-direction: column; transform: translateX(-100%); transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1); position: fixed; left: 0; top: 0; height: 100%; z-index: 100; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #sidebar.open { transform: translateX(0); }
        .social-login-container { display: flex; gap: 0.75rem; align-items: center; } .social-btn { background-color: #2d2d33; border: 1px solid #444; color: white; padding: 0.5rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s; width: 36px; height: 36px; font-size: 1.1rem; } .social-btn:hover { background-color: #444; border-color: var(--primary-yellow); }
        #new-chat-btn { background-color: transparent; border: 1px solid var(--primary-yellow); color: var(--primary-yellow); width: 100%; text-align: center; transition: all 0.2s ease; margin-top: 1rem; } #new-chat-btn:hover { background-color: var(--primary-yellow); color: var(--dark-bg); }
        .history-item { padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: all 0.2s; border-left: 3px solid transparent; } .history-item:hover { background-color: var(--main-bg); color: var(--text-primary); } .history-item.active { background-color: #27272a; color: white; font-weight: 500; border-left-color: var(--primary-yellow); }
        #chat-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; max-width: 900px; margin: 0 auto; padding: 1rem; transition: margin-left 0.4s cubic-bezier(0.25, 1, 0.5, 1); margin-left: auto; margin-right: auto; position: relative; }
        #sidebar.open ~ #chat-container { margin-left: 260px; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 0 0.5rem; position: relative; z-index: 50; }
        .menu-btn, #settings-btn { font-size: 1.8rem; cursor: pointer; color: var(--primary-yellow); z-index: 51; transition: transform 0.2s; }
        .menu-btn:hover, #settings-btn:hover { transform: scale(1.1); }
        .chat-box { background: transparent; padding: 1rem; flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; scroll-behavior: smooth; margin-top: 1rem; gap: 1rem; }
        .message-group { display: flex; gap: 12px; max-width: 90%; } .message-group.user { align-self: flex-end; flex-direction: row-reverse; } .message-group.ai { align-self: flex-start; }
        .avatar { width: 32px; height: 32px; border-radius: 50%; background: #444; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-top: 4px; } .avatar-user { background: #5e5ce6; color: white; } .avatar-ai { background: var(--primary-yellow); color: #111; }
        @keyframes fadeInBubble { from { opacity: 0; transform: translateY(10px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } } .bubble { padding: 12px 18px; border-radius: 18px; line-height: 1.6; word-wrap: break-word; white-space: pre-wrap; animation: fadeInBubble 0.3s ease-out forwards; box-shadow: 0 4px 15px rgba(0,0,0,0.2); } .user .bubble { background: var(--bubble-user-bg); color: white; border-bottom-right-radius: 4px; } .ai .bubble { background: var(--bubble-ai-bg); color: var(--text-primary); border-bottom-left-radius: 4px; }
        .welcome-message { text-align: center; color: var(--text-secondary); padding: 2rem 1rem; animation: fadeInBubble 0.5s ease; } .welcome-message h2 { font-size: 1.8rem; font-weight: bold; color: var(--text-primary); }
        .typing-indicator { display: flex; align-items: center; gap: 5px; } .typing-indicator span { width: 8px; height: 8px; background-color: #777; border-radius: 50%; animation: typing 1s infinite; } .typing-indicator span:nth-child(2) { animation-delay: 0.2s; } .typing-indicator span:nth-child(3) { animation-delay: 0.4s; } @keyframes typing { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        pre { background-color: #0d1117; color: #c9d1d9; padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid #30363d; font-size: 0.9em; } code { font-family: 'Courier New', Courier, monospace; }
        .input-area { margin-top: 1rem; padding: 0.5rem; background: var(--main-bg); border-radius: 1rem; box-shadow: 0 -5px 20px rgba(0,0,0,0.2); }
        .mode-selector { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; justify-content: center; position: relative; }
        .mode-btn { background: #2d3748; padding: 0.5rem 1rem; border-radius: 20px; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s; border: 2px solid transparent; font-size: 0.9rem; color: var(--text-secondary); } .mode-btn:hover:not(:disabled) { background: #4a5568; color: var(--text-primary); } .mode-btn.active { border-color: var(--primary-yellow); background-color: #374151; color: var(--primary-yellow); font-weight: 500; } .mode-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .hidden-modes { position: absolute; bottom: 100%; right: 0; left: 0; background: var(--main-bg); border-radius: 10px; padding: 10px; margin-bottom: 8px; box-shadow: 0 -5px 15px rgba(0,0,0,0.3); display: flex; flex-wrap: wrap; gap: 8px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, border-width 0.3s ease-in-out; border: 1px solid transparent; z-index: 10; justify-content: center; }
        .hidden-modes.open { max-height: 300px; border: 1px solid #333; padding: 10px; }
        .mode-selector > .mode-btn { padding: 0.5rem 1.5rem; }
        #mode-expand-btn { background: #2d3748; color: var(--primary-yellow); border-radius: 50%; width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; line-height: 1; transition: transform 0.3s ease; z-index: 11; }
        #mode-expand-btn:hover { background: #4a5568; transform: rotate(90deg); }
        .input-row { display: flex; align-items: flex-end; gap: 0.75rem; background: var(--input-bg); padding: 0.5rem; border-radius: 0.75rem; border: 1px solid #333; transition: border-color 0.2s; } .input-row:focus-within { border-color: var(--primary-yellow); }
        textarea:disabled { opacity: 0.6; cursor: not-allowed; }
        .icon-btn:disabled, .send-btn:disabled { opacity: 0.5; cursor: not-allowed !important; transform: none !important; background-color: #2d3748 !important; color: var(--text-secondary) !important; }
        textarea { width: 100%; padding: 0.6rem; border-radius: 0.5rem; background: transparent; border: none; color: white; resize: none; outline: none; max-height: 200px; font-size: 1rem; line-height: 1.5; }
        .icon-btn, .send-btn { background: transparent; padding: 10px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: none; color: var(--text-secondary); flex-shrink: 0; } .icon-btn:hover:not(:disabled) { color: var(--primary-yellow); background: #374151; } .send-btn { background: var(--primary-yellow); color: var(--dark-bg); } .send-btn:hover:not(:disabled) { transform: scale(1.1); }
        .pending-preview { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; padding: 0.5rem; } .pending-preview img { width: 60px; height: 60px; object-fit: cover; border-radius: 8px; border: 2px solid #475569; }
        img.generated-image, .generated-video { border-radius: 12px; max-width: 100%; margin-top: 1rem; display: block; max-height: 400px; margin-left: auto; margin-right: auto; }
        #settings-modal { position: absolute; top: 3rem; right: 1rem; width: 200px; background: var(--main-bg); border: 1px solid var(--primary-yellow); border-radius: 0.75rem; padding: 1rem; display: none; z-index: 100; }
        #voice-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); z-index: 1500; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; }
        .mic-wave-container { width: 200px; height: 200px; border-radius: 50%; display: flex; align-items: center; justify-content: center; position: relative; } .mic-wave-container.listening .wave { animation: ripple 1.5s ease-out infinite; } .mic-wave-container .wave { position: absolute; width: 100%; height: 100%; border: 4px solid var(--primary-yellow); border-radius: 50%; opacity: 0; } .mic-wave-container .wave:nth-child(2) { animation-delay: 0.3s; } .mic-wave-container .wave:nth-child(3) { animation-delay: 0.6s; } @keyframes ripple { from { transform: scale(0.5); opacity: 1; } to { transform: scale(1.5); opacity: 0; } }
        .mic-icon { font-size: 3rem; color: #111; background-color: var(--primary-yellow); border-radius: 50%; padding: 20px; z-index: 10; cursor: pointer; }
        #limit-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 2000; display: none; align-items: center; justify-content: center; flex-direction: column; } #password-form { background: var(--main-bg); padding: 2.5rem; border-radius: 1rem; text-align: center; border: 3px solid var(--primary-yellow); box-shadow: 0 0 30px rgba(250, 204, 21, 0.3); }
        .summary-actions { margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 0.5rem; border-top: 1px solid #444; padding-top: 0.75rem; }
        .summary-btn { background-color: #374151; color: #e5e7eb; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.8rem; cursor: pointer; transition: background-color 0.2s; border: none; }
        .summary-btn:hover:not(:disabled) { background-color: #4b5563; }
        .summary-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        /* --- THÊM MỚI: CSS cho Gamification --- */
        #gamification-stats { padding: 0.5rem 0.25rem; margin-top: 1rem; border-top: 1px solid #27272a; }
        .stat-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .stat-item span { font-size: 0.9rem; color: var(--text-secondary); }
        .stat-item .value { font-weight: bold; color: var(--text-primary); }
        .xp-bar-container { background-color: #2d2d33; border-radius: 99px; height: 10px; overflow: hidden; width: 100%; }
        .xp-bar { background-color: var(--primary-yellow); height: 100%; width: 0%; transition: width 0.5s ease; }
        /* --- Hết CSS --- */
    </style>
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
</head>
<body>
    <div id="intro-screen">
        <div class="intro-container">
            <div id="intro-yellow-flash"></div>
            <div id="intro-text">AI Assistant Pro</div>
            <div id="intro-burst"></div>
        </div>
    </div>
    <audio id="intro-audio" src="data:audio/mpeg;base64,..."></audio>

    <div id="limit-overlay">
        <div id="password-form">
             <h2 class="text-2xl font-bold mb-4 text-yellow-500">Đã hết lượt sử dụng miễn phí hôm nay!</h2>
             <p id="limit-message" class="mb-6 text-gray-300">Vui lòng nhập mật khẩu để mở khóa sử dụng không giới hạn:</p>
             <input type="password" id="password-input" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-yellow-500 outline-none" placeholder="Mật khẩu">
             <button id="unlock-btn" class="mt-4 p-3 bg-yellow-500 text-black font-bold rounded-lg w-full hover:bg-yellow-600 transition">Mở khóa Vô Hạn</button>
             <p id="password-message" class="mt-3 text-red-500 hidden"></p>
        </div>
    </div>
     <div id="voice-overlay">
        <div class="mic-wave-container" id="mic-wave">
            <div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="mic-icon" id="voice-mic-icon">🎤</div>
        </div>
        <p id="voice-status" class="mt-6 text-xl font-medium text-yellow-500">Nhấn Mic để Bắt đầu Nói...</p>
        <button id="voice-close-btn" class="mt-10 p-3 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition">Tắt Chức Năng Giọng Nói</button>
    </div>

    <div id="app-wrapper">
        <aside id="sidebar">
             <div class="social-login-container mb-4">
                 <button onclick="alert('Đăng nhập Google đang phát triển!')" class="social-btn" title="Đăng nhập với Google"><i class="fab fa-google"></i></button>
                 <button onclick="alert('Đăng nhập Facebook đang phát triển!')" class="social-btn" title="Đăng nhập với Facebook"><i class="fab fa-facebook-f"></i></button>
                 <button onclick="alert('Đăng nhập GitHub đang phát triển!')" class="social-btn" title="Đăng nhập với GitHub"><i class="fab fa-github"></i></button>
             </div>
             <button id="new-chat-btn" class="p-3 rounded-lg font-bold">＋ New Conversation</button>
             
             <div id="gamification-stats">
                 <h3 class="text-gray-400 text-sm font-bold mb-2 uppercase">Tiến độ của bạn</h3>
                 <div class="stat-item">
                     <span>🔥 Chuỗi ngày (Streak):</span>
                     <span id="streak-counter" class="value">0 ngày</span>
                 </div>
                 <div class="stat-item">
                     <span id="level-counter">Cấp 0</span>
                     <span id="xp-counter" class="value">0/100 XP</span>
                 </div>
                 <div class="xp-bar-container">
                     <div id="xp-bar" class="xp-bar"></div>
                 </div>
             </div>
             
             <h2 class="text-gray-400 text-sm font-bold mt-6 mb-2 uppercase">History</h2>
             <div id="chat-history" class="flex-grow overflow-y-auto"></div>
             <div id="usage-counter" class="text-center text-sm text-gray-400 mt-auto pt-4 border-t border-gray-700">Loading usage...</div>
        </aside>

        <main id="chat-container">
            <div class="header relative">
                 <div id="menu-btn" class="menu-btn">☰</div>
                 <div class="flex-grow"></div>
                 <div id="settings-btn">⚙️</div>
                 <div id="settings-modal">
                     <label class="block mb-2">Chat Language:</label>
                     <select id="language-select" class="w-full p-2 rounded bg-gray-800 text-white">
                         <option value="vi">Tiếng Việt</option>
                         <option value="en">English</option>
                         <option value="zh-CN">简体中文</option>
                     </select>
                 </div>
            </div>
            <div class="chat-box" id="chatBox"></div>
            <div class="input-area">
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="chat" title="Trò chuyện"><span>💬 Chat</span></button>
                    <button id="mode-expand-btn" class="icon-btn" title="Chức năng mở rộng">
                        <span id="expand-icon">+</span>
                    </button>
                    <div id="hidden-modes" class="hidden-modes">
                        <button class="mode-btn" data-mode="persona" title="Nhập vai nhân vật"><span>🎭 Nhập Vai</span></button>
                        <button class="mode-btn" data-mode="image" title="Tạo ảnh"><span>🖼️ Tạo Ảnh</span></button>
                        <button class="mode-btn" data-mode="math" title="Giải toán"><span>🧮 Giải Toán</span></button>
                        <button class="mode-btn" data-mode="video" title="Tạo video"><span>🎥 Tạo Video</span></button>
                        <button class="mode-btn" data-mode="edit_image" title="Chỉnh sửa ảnh"><span>✍️ Sửa Ảnh</span></button>
                        <button class="mode-btn" data-mode="summarize_youtube" title="Tóm tắt YouTube"><span>▶️ Tóm Tắt YT</span></button>
                        <button class="mode-btn" data-mode="notetaker" title="Ghi chú văn bản"><span>📝 Ghi Chú</span></button>
                        <button class="mode-btn" data-mode="analyze_stock" title="Phân tích Chứng khoán"><span>📈 Chứng Khoán</span></button>
                        <button class="mode-btn" data-mode="marketing" title="Viết Content Marketing"><span>📢 Marketing</span></button>
                        <button class="mode-btn" data-mode="music" title="Sáng tác Nhạc (Lời & Hợp âm)"><span>🎵 Tạo Nhạc</span></button>
                    </div>
                </div>
                <div class="pending-preview" id="previewContainer"></div>
                <div class="input-row">
                    <label class="icon-btn" for="fileInput" title="Tải ảnh">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M6.5 12.5a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM.5 4.5A.5.5 0 0 1 1 4h14a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5zM3 8.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 8.5z"/></svg>
                    </label>
                    <input type="file" id="fileInput" accept="image/*" hidden />
                    <button id="voiceBtn" class="icon-btn" title="Trò chuyện bằng giọng nói">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/></svg>
                    </button>
                    <textarea id="mainInput" rows="1" placeholder="Ask me anything..."></textarea>
                    <button id="sendBtn" class="send-btn" title="Gửi">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="22" height="22" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Khai báo biến DOM ---
        const getEl = (id) => document.getElementById(id);
        const introScreen = getEl('intro-screen'), appWrapper = getEl('app-wrapper'), introAudio = getEl('intro-audio');
        const sidebar = getEl('sidebar'), menuBtn = getEl('menu-btn'), chatContainer = getEl('chat-container'), chatBox = getEl('chatBox'), mainInput = getEl('mainInput'), sendBtn = getEl('sendBtn'), fileInput = getEl('fileInput'), previewContainer = getEl('previewContainer'), languageSelect = getEl('language-select'), settingsBtn = getEl('settings-btn'), settingsModal = getEl('settings-modal'), newChatBtn = getEl('new-chat-btn'), chatHistoryContainer = getEl('chat-history');
        const voiceBtn = getEl('voiceBtn'), voiceOverlay = getEl('voice-overlay'), voiceCloseBtn = getEl('voice-close-btn'), voiceStatus = getEl('voice-status'), voiceMicIcon = getEl('voice-mic-icon'), micWave = getEl('mic-wave');
        const limitOverlay = getEl('limit-overlay'), passwordInput = getEl('password-input'), unlockBtn = getEl('unlock-btn'), passwordMessage = getEl('password-message');
        const modeButtons = document.querySelectorAll('.mode-selector .mode-btn');
        const expandBtn = getEl('mode-expand-btn');
        const hiddenModesContainer = getEl('hidden-modes');
        const usageCounterEl = getEl('usage-counter');
        const fileInputLabel = fileInput.labels[0];
        // DOM mới cho Gamification
        const streakCounterEl = getEl('streak-counter');
        const levelCounterEl = getEl('level-counter');
        const xpCounterEl = getEl('xp-counter');
        const xpBarEl = getEl('xp-bar');


        let currentChatMode = 'chat', uploadedFile = null, chatHistory = {}, activeChatId = null, isRecording = false;
        let currentPersonaDesc = localStorage.getItem('ai_pro_persona_desc') || '';
        let isModeExpanded = false;

        // === Logic Giới Hạn Hàng Ngày & Gamification (Gộp chung) ===
        const MAX_DAILY_USES = 20;
        const UNLOCK_PASSWORD = "Hoang1082009@";
        // Dùng một object duy nhất để lưu trữ dữ liệu người dùng
        let userData = {
            count: 0,
            date: '',
            unlocked: false,
            streak: 0,
            lastStreakDate: '',
            xp: 0
        };
        
        function getTodayString() { return new Date().toDateString(); }
        function getYesterdayString() { return new Date(Date.now() - 86400000).toDateString(); }

        function loadUserData() {
            const today = getTodayString();
            const yesterday = getYesterdayString();
            const storedData = JSON.parse(localStorage.getItem('ai_pro_userdata_v1')) || {};

            // Gộp dữ liệu đã lưu
            userData = { ...userData, ...storedData };

            // 1. Logic Giới hạn lượt dùng
            if (userData.unlocked) {
                userData.date = today;
            } else if (userData.date !== today) {
                userData.count = 0; // Reset lượt dùng
                userData.date = today;
            }
            
            // 2. Logic Gamification (Streak)
            if (userData.lastStreakDate === yesterday) {
                // Tiếp tục streak
                userData.streak++;
                userData.lastStreakDate = today;
            } else if (userData.lastStreakDate !== today) {
                // Bắt đầu streak mới (hoặc reset)
                userData.streak = 1;
                userData.lastStreakDate = today;
            }
            // Nếu lastStreakDate == today, không làm gì cả
            
            saveUserData(); // Lưu lại (đặc biệt là date mới và streak)
            checkUsageLimit(); // Kiểm tra ngay khi tải
        }
        function saveUserData() {
            localStorage.setItem('ai_pro_userdata_v1', JSON.stringify(userData));
            updateUsageDisplay();
            updateGamificationUI();
        }
        function updateUsageDisplay() {
            if (!usageCounterEl) return;
            usageCounterEl.innerHTML = userData.unlocked
                ? `<span class="text-green-400 font-bold">Vô hạn</span> | <a href="#" id="lock-limit" class="text-red-400 hover:text-red-300">Khóa Lại</a>`
                : `Còn lại: <span class="text-yellow-400 font-bold">${Math.max(0, MAX_DAILY_USES - userData.count)}</span> lượt`;
            document.getElementById('lock-limit')?.addEventListener('click', (e) => {
                e.preventDefault();
                if (confirm("Bạn chắc chắn muốn khóa lại giới hạn sử dụng không?")) {
                    userData.unlocked = false; userData.count = 0; saveUserData(); checkUsageLimit();
                }
            });
        }
        function updateGamificationUI() {
            if (!streakCounterEl || !xpCounterEl || !xpBarEl || !levelCounterEl) return;
            
            const level = Math.floor(userData.xp / 100);
            const xpForNextLevel = 100;
            const currentXPInLevel = userData.xp % xpForNextLevel;
            
            streakCounterEl.textContent = `${userData.streak} ngày`;
            levelCounterEl.textContent = `Cấp ${level}`;
            xpCounterEl.textContent = `${currentXPInLevel}/${xpForNextLevel} XP`;
            xpBarEl.style.width = `${currentXPInLevel}%`;
        }
        function checkUsageLimit() {
            const isLocked = !userData.unlocked && userData.count >= MAX_DAILY_USES;
            limitOverlay.style.display = isLocked ? 'flex' : 'none';
            const controls = [mainInput, sendBtn, voiceBtn, fileInput, ...modeButtons, expandBtn];
            controls.forEach(el => {
                if (el) {
                    el.disabled = isLocked;
                    const targetElement = el.tagName === 'INPUT' && el.type === 'file' ? fileInputLabel : el;
                    if (targetElement) {
                         targetElement.style.opacity = isLocked ? '0.5' : '1'; targetElement.style.cursor = isLocked ? 'not-allowed' : 'pointer';
                    }
                }
            });
            if (isLocked) toggleModeExpand(true);
            return !isLocked;
        }
        function incrementUsageCount() {
            if (!userData.unlocked) {
                userData.count++;
            }
            // Thêm XP cho mỗi lần sử dụng
            userData.xp += 10;
            saveUserData(); // Lưu cả count và xp, cập nhật UI
            if (!userData.unlocked) checkUsageLimit();
        }
        unlockBtn.addEventListener('click', () => {
            if (passwordInput.value === UNLOCK_PASSWORD) {
                userData.unlocked = true; userData.date = new Date().toDateString(); saveUserData();
                checkUsageLimit();
                passwordMessage.textContent = 'Mở khóa thành công!'; passwordMessage.className = 'mt-3 text-green-500';
                passwordInput.value = '';
                setTimeout(() => { limitOverlay.style.display = 'none'; passwordMessage.className = 'mt-3 text-red-500 hidden'; }, 1500);
            } else {
                passwordMessage.textContent = 'Mật khẩu sai.'; passwordMessage.className = 'mt-3 text-red-500';
            }
        });

        // === Logic Intro Screen ===
        function playIntro() {
            introScreen.style.display = 'flex';
            try { introAudio.play().catch(e => {}); } catch(e) {}
            setTimeout(() => {
                introScreen.style.opacity = '0';
                appWrapper.style.opacity = '1';
                setTimeout(() => { introScreen.style.display = 'none'; appWrapper.style.zIndex = 'auto'; document.body.style.overflow = 'auto'; }, 1000);
            }, 6000);
        }

        // === Logic Voice Chat ===
        let conversationMode = false; let silenceTimeout;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        
        if (SpeechRecognition) {
            recognition = new SpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; recognition.lang = 'vi-VN';
            recognition.onresult = (event) => { clearTimeout(silenceTimeout); const transcript = event.results[0][0].transcript; voiceStatus.textContent = `Bạn: "${transcript}"`; handleVoiceQuery(transcript, recognition.lang); };
            recognition.onend = () => { isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = '🎤'; if (conversationMode && !speechSynthesis.speaking) startListening(); else if (!conversationMode) voiceStatus.textContent = "Nhấn Mic để Bắt đầu Nói..."; };
            recognition.onerror = (event) => { console.error("Speech Error:", event.error); voiceStatus.textContent = `Lỗi: ${event.error}`; isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = '🎤'; if (!conversationMode) setTimeout(() => voiceOverlay.style.display = 'none', 3000); };
        } else { voiceBtn.style.display = 'none'; }
        function startListening() {
             if (!recognition || isRecording) { if(isRecording) recognition.stop(); return; }
             voiceStatus.textContent = "Đang Nghe..."; micWave.classList.add('listening'); voiceMicIcon.textContent = '🔴'; isRecording = true;
             recognition.lang = languageSelect.value === 'en' ? 'en-US' : (languageSelect.value === 'zh-CN' ? 'zh-CN' : 'vi-VN');
             clearTimeout(silenceTimeout); silenceTimeout = setTimeout(() => { if (isRecording) recognition.stop(); voiceStatus.textContent = "Hết thời gian chờ."; }, 7000);
             try { recognition.start(); } catch(e) { voiceStatus.textContent = `Lỗi: ${e.message}`; isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = '🎤'; }
        }
        function speak(text, lang) { return new Promise(resolve => { if (!speechSynthesis) { resolve(); return; } speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang.includes('-') ? lang : (lang === 'en' ? 'en-US' : (lang === 'zh-CN' ? 'zh-CN' : 'vi-VN')); u.onstart = () => voiceStatus.textContent = "AI Đang Phản Hồi..."; u.onend = () => { voiceStatus.textContent = "Nhấn Mic để Bắt đầu Nói..."; resolve(); }; u.onerror = (e) => { console.error("Speak Error:", e); voiceStatus.textContent = `Lỗi phát âm: ${e.error}`; resolve(); }; setTimeout(() => speechSynthesis.speak(u), 100); }); }
        async function handleVoiceQuery(transcript, langCode) {
             voiceStatus.textContent = "AI Processing...";
            try {
                const shortLang = langCode.split('-')[0];
                const systemInstruction = getSystemInstruction(shortLang);
                const responseData = await callApi('/api/chat', { message: transcript, image: null, language: shortLang, systemInstruction: systemInstruction });
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = responseData.response;
                const aiReplyText = tempDiv.textContent || tempDiv.innerText || "";
                if (!aiReplyText || aiReplyText.startsWith('❌')) throw new Error(aiReplyText || "AI response invalid.");
                await speak(aiReplyText, langCode);
            } catch (error) {
                const errorMsg = error.message.includes('HTTP Error') ? "Problem connecting." : error.message.startsWith('❌') ? error.message.substring(2) : "Error processing.";
                await speak(errorMsg, langCode);
            } finally {
                incrementUsageCount(); // Tăng XP và lượt dùng
                if (conversationMode && !speechSynthesis.speaking) startListening();
                else if (!conversationMode) setTimeout(() => voiceOverlay.style.display = 'none', 500);
            }
        }
        voiceBtn.addEventListener('click', () => { if (!checkUsageLimit()) return; if (!recognition) return alert("Not supported."); if (!window.isSecureContext && window.location.protocol !== 'http:') return alert('Requires HTTPS/localhost.'); voiceStatus.textContent = "Nhấn Mic để Bắt đầu Nói..."; micWave.classList.remove('listening'); voiceMicIcon.textContent = '🎤'; voiceOverlay.style.display = 'flex'; conversationMode = true; startListening(); });
        voiceMicIcon.addEventListener('click', () => { if (isRecording) recognition.stop(); else startListening(); });
        voiceCloseBtn.addEventListener('click', () => { conversationMode = false; if (isRecording) recognition.stop(); speechSynthesis.cancel(); voiceOverlay.style.display = 'none'; });

        // === Flashcard & Mindmap Rendering (Đã sửa lỗi hiển thị ngay đáp án và lỗi không vẽ được) ===
        function renderFlashcards(rawText) {
            const cardPairs = rawText.split('\nQ:').filter(c => c.trim()).map(c => {
                if (!c.startsWith('Q:')) c = 'Q:' + c;
                const parts = c.split('\nA:');
                const question = parts[0].replace('Q:', '').trim();
                const answer = parts[1] ? parts[1].trim() : 'No Answer Provided';
                return { question, answer };
            });

            let html = `<div class="flashcard-list grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">`;

            cardPairs.forEach((pair, index) => {
                const cardId = `card-${Date.now()}-${index}-${Math.floor(Math.random() * 1000)}`;
                html += `
                    <div class="flashcard-item bg-gray-700 rounded-lg shadow-lg overflow-hidden border-2 border-gray-600">
                        <div id="${cardId}-q" class="p-4 bg-gray-800 text-white font-bold cursor-pointer hover:bg-gray-700 transition" onclick="
                            const a = document.getElementById('${cardId}-a');
                            const q = document.getElementById('${cardId}-q');
                            if (a.style.display === 'none') {
                                a.style.display = 'block';
                                q.style.backgroundColor = '#1f2937'; // bg-gray-800 on click
                                q.classList.remove('font-bold');
                            } else {
                                a.style.display = 'none';
                                q.style.backgroundColor = '#1f2937'; // bg-gray-800
                                q.classList.add('font-bold');
                            }
                        ">
                            <span class="text-yellow-400">Q:</span> ${pair.question}
                        </div>
                        <div id="${cardId}-a" class="p-4 bg-gray-900 text-yellow-400" style="display:none;">
                            <span class="text-gray-400">A:</span> ${pair.answer}
                        </div>
                    </div>`;
            });

            html += `</div>`;
            return html;
        }

        function renderMindmap(rawText) {
            // Chuyển đổi Markdown List sang định dạng Mindmap của Mermaid
            let mindmapText = "mindmap\n";
            const lines = rawText.split('\n');
            let rootNode = null;

            for (const line of lines) {
                const match = line.match(/^(\s*)[\*\-]\s+(.*)$/);
                if (!match) continue;

                const indentLevel = match[1].length / 2; // Giả sử 2 space/tab cho mỗi cấp
                const text = match[2].trim().replace(/[\[\]\(\)]/g, ''); // Loại bỏ ký tự xung đột

                if (indentLevel === 0) {
                    if (!rootNode) {
                        rootNode = text;
                        mindmapText += `  root((${text}))\n`;
                    } else {
                        // Xử lý nếu có nhiều root (chuyển thành nhánh lớn)
                        mindmapText += `  ${text}((${text}))\n`;
                    }
                } else if (rootNode) {
                    const indent = '  '.repeat(indentLevel + 1);
                    mindmapText += `${indent}${text}\n`;
                }
            }
            
            // Trả về HTML với class="mermaid" để thư viện tự render
            return `<div class="mermaid text-center p-4" style="background-color: #1a1a1e; border-radius: 8px; border: 1px solid #333; overflow-x: auto; max-width: 100%;">${mindmapText}</div>`;
        }

        function addSummaryActions(bubbleElement, summaryText) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'summary-actions';
            actionsDiv.innerHTML = `
                <button class="summary-btn" data-action="flashcard">Tạo Flashcards</button>
                <button class="summary-btn" data-action="mindmap">Tạo Mindmap</button>
            `;
            actionsDiv.querySelectorAll('.summary-btn').forEach(button => {
                button.addEventListener('click', async () => {
                    if (!checkUsageLimit()) return;
                    const action = button.dataset.action;
                    const endpoint = action === 'flashcard' ? '/api/generate-flashcards' : '/api/generate-mindmap';
                    button.textContent = 'Đang tạo...'; button.disabled = true;
                    const loadingBubble = showLoading();
                    
                    try {
                        const response = await callApi(endpoint, { textToConvert: summaryText });
                        if (response.response.startsWith('❌')) throw new Error(response.response);
                        
                        let finalHtml = '';
                        let saveTag = '';
                        
                        if (action === 'flashcard') {
                            finalHtml = renderFlashcards(response.response);
                            saveTag = `[FLASHCARD_START]${response.response}[FLASHCARD_END]`;
                        } else { // mindmap
                            finalHtml = renderMindmap(response.response);
                            saveTag = `[MINDMAP_START]${response.response}[MINDMAP_END]`;
                        }
                        
                        loadingBubble.querySelector('.bubble').innerHTML = finalHtml;
                        saveMessage(saveTag, 'ai');
                        
                        // Manually re-init Mermaid if mindmap
                        if (action === 'mindmap' && window.mermaid) {
                             setTimeout(() => {
                                 // Tắt tự động khởi tạo trước khi gọi init
                                 window.mermaid.contentLoaded();
                                 window.mermaid.init(undefined, loadingBubble.querySelector('.mermaid'));
                             }, 100);
                        }

                        incrementUsageCount(); 
                    } catch (error) {
                        loadingBubble.querySelector('.bubble').innerHTML = `❌ Lỗi tạo ${action}: ${error.message}`;
                        saveMessage(loadingBubble.querySelector('.bubble').innerHTML, 'ai');
                    } finally {
                        button.textContent = action === 'flashcard' ? 'Tạo Flashcards' : 'Tạo Mindmap';
                        button.disabled = false;
                    }
                });
            });
            bubbleElement.appendChild(actionsDiv);
        }

        // === Cá nhân hóa AI (Đã sửa lỗi bị ghi đè vai trò) ===
        function getSystemInstruction(lang) {
            const langName = { 'vi': 'Tiếng Việt', 'en': 'English', 'zh-CN': '简体中文' }[lang] || 'Tiếng Việt';
            
            // 📌 FIX 3B: Gợi ý tiếp theo không tự nhiên
            let followUpSuggestion = `**At the end of your response, always suggest one logical follow-up topic or question for the user to explore next, enclosed in italics (e.g., *Bạn có muốn xem một ví dụ khác không?*).**`;


            let baseInstruction = `You are a helpful AI assistant. Respond in **${langName}**. Be concise, use markdown, highlight <mark class="highlight">...</mark>. Analyze image if provided. ${followUpSuggestion}`;

            if (currentChatMode === 'persona' && currentPersonaDesc) {
                // 📌 FIX 3A: Cải thiện Nhập vai (Inhuman response)
                const personaIntro = "I can become any role in the world. If the user enters a famous person, wife, sister, or historical figure, I will recognize that character and answer all questions in that role.";
                const personaInstruction = `IMPORTANT: You must act as the following character: "${currentPersonaDesc}". Respond CONSISTENTLY in this role to all user input. Respond in **${langName}**. Keep answers concise, use markdown, highlight <mark class="highlight">...</mark>. ${personaIntro}
                **SENSITIVE TOPICS RULE:** If the user asks a sensitive or inappropriate question, do NOT revert to stating you are an AI model. Instead, handle the situation *in character* by deflecting, avoiding, expressing offense, or responding creatively as the persona.
                **At the end, suggest one follow-up question *in character* (e.g., *Ngươi có muốn hỏi thêm về định luật vạn vật hấp dẫn không?*).**`;
                baseInstruction = personaInstruction;
            }
            return baseInstruction;
        }
        function setPersona(description) {
            currentPersonaDesc = description.trim();
            localStorage.setItem('ai_pro_persona_desc', currentPersonaDesc);
            const introMessage = `Tuyệt vời! Từ giờ tôi sẽ nhập vai: **${currentPersonaDesc}**. Hãy hỏi tôi bất cứ điều gì! <br><br> (Ghi chú: Tôi có thể biến thành vai trò của bất kể người nào trên thế giới và nếu người dùng nhập một nhân vật nổi tiếng, vợ, em gái hay trong lịch sử, tôi sẽ nhận biết nhân vật đó và khi người dùng hỏi cái gì, tôi cũng sẽ trả lời trong vai trò đó.)
            <br><br>Gõ **!clearpersona** để tôi trở lại thành trợ lý AI.
            <br><br>*Bạn muốn bắt đầu với câu hỏi gì trong vai trò này?*`;
            appendMessage(introMessage, 'ai', true); // Lưu tin nhắn này vào history
        }

        // --- Core Chat Logic ---
        function saveHistoryToStorage() { localStorage.setItem('ai_chat_history_v3', JSON.stringify(chatHistory)); }
        function loadHistoryFromStorage() { chatHistory = JSON.parse(localStorage.getItem('ai_chat_history_v3')) || {}; }

        function appendMessage(content, type, save = true) {
             const messageGroup = document.createElement('div'); messageGroup.className = `message-group ${type}`;
             const avatar = document.createElement('div'); avatar.className = `avatar avatar-${type}`; avatar.innerHTML = type === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-robot"></i>'; // Dùng icon
             const bubble = document.createElement('div'); bubble.className = 'bubble';
             bubble.innerHTML = content.replace(/\n/g, '<br>'); // Hiển thị xuống dòng
             messageGroup.appendChild(avatar); messageGroup.appendChild(bubble); chatBox.appendChild(messageGroup);
             setTimeout(() => chatBox.scrollTop = chatBox.scrollHeight, 50);
             if (save) saveMessage(content, type);
             return messageGroup;
        }
        function saveMessage(content, type) {
            if (!activeChatId || !chatHistory[activeChatId]) return;
            if (!Array.isArray(chatHistory[activeChatId].messages)) chatHistory[activeChatId].messages = [];
            chatHistory[activeChatId].messages.push({ content, type, timestamp: Date.now() });
            saveHistoryToStorage();
        }
        function displayWelcomeMessage() {
            chatBox.innerHTML = `<div class="welcome-message"><h2>AI Assistant Pro 🤖</h2><p class="mt-4">How can I help you today?</p><p class="mt-2 text-sm text-gray-500">(Sử dụng nút <span class="text-yellow-500 font-bold">+</span> để khám phá các chức năng...)</p></div>`;
        }
        function startNewChat() {
            // 📌 FIX 2: Reset Persona khi tạo chat mới
            currentPersonaDesc = ''; 
            localStorage.removeItem('ai_pro_persona_desc');
            
            activeChatId = `chat_${Date.now()}`;
            chatHistory[activeChatId] = { title: 'New Conversation', messages: [] };
            displayWelcomeMessage();
            renderChatHistory();
            saveHistoryToStorage();
            handleModeSelection('chat'); // Quay về chế độ chat mặc định
        }
        function loadChat(chatId) {
            if (!chatHistory[chatId]) return startNewChat();
            activeChatId = chatId; chatBox.innerHTML = '';
            const messages = chatHistory[activeChatId].messages || [];
            if (messages.length === 0) displayWelcomeMessage();
            else messages.forEach(msg => {
                let content = msg.content;
                let isFlashcard = false;
                let isMindmap = false;
                
                // 1. Check for Flashcard History
                if (content.startsWith('[FLASHCARD_START]') && content.endsWith('[FLASHCARD_END]')) {
                    const rawText = content.substring('[FLASHCARD_START]'.length, content.length - '[FLASHCARD_END]'.length);
                    content = renderFlashcards(rawText);
                    isFlashcard = true;
                }
                
                // 2. Check for Mindmap History
                else if (content.startsWith('[MINDMAP_START]') && content.endsWith('[MINDMAP_END]')) {
                    const rawText = content.substring('[MINDMAP_START]'.length, content.length - '[MINDMAP_END]'.length);
                    content = renderMindmap(rawText);
                    isMindmap = true;
                }

                const msgGroup = appendMessage(content, msg.type, false);
                
                // 3. Thêm lại nút action nếu là summary (và chưa chuyển đổi)
                const isSummary = msg.type === 'ai' && (msg.content.includes("key points") || msg.content.includes("## Key Points") || msg.content.includes("Tóm tắt") || msg.content.includes("Marketing"));
                if (isSummary && !msg.content.startsWith('❌') && !isFlashcard && !isMindmap) {
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = msg.content;
                    const summaryText = tempDiv.textContent || tempDiv.innerText || "";
                    addSummaryActions(msgGroup.querySelector('.bubble'), summaryText);
                }
            });
            
            // Re-render Mermaid sau khi tải lịch sử
            setTimeout(() => {
                if (window.mermaid) {
                    window.mermaid.contentLoaded();
                    window.mermaid.init(undefined, document.querySelectorAll('.mermaid'));
                }
            }, 50);

            renderChatHistory();
            // Không chuyển mode khi load chat để giữ lại mode hiện tại nếu là persona/stock
            // handleModeSelection('chat'); 
        }
         function renderChatHistory() {
             chatHistoryContainer.innerHTML = '';
             const sortedKeys = Object.keys(chatHistory).sort((a, b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]));
             sortedKeys.forEach(key => {
                 const chat = chatHistory[key];
                 if (chat && chat.title) {
                     const item = document.createElement('div');
                     item.className = `history-item ${key === activeChatId ? 'active' : ''}`;
                     item.dataset.chatId = key;
                     item.textContent = chat.title;
                     item.addEventListener('click', () => { loadChat(key); sidebar.classList.remove('open'); });
                     chatHistoryContainer.appendChild(item);
                 }
             });
             if (chatHistoryContainer.innerHTML === '') {
                  chatHistoryContainer.innerHTML = '<div class="text-center text-gray-500 mt-4">No history.</div>';
             }
         }
        function updateChatTitle(firstUserMessage, isImageOnly = false) {
             if (!activeChatId || !chatHistory[activeChatId]) return;
             if (chatHistory[activeChatId].title === 'New Conversation') {
                 let newTitle = "Untitled";
                 if (firstUserMessage) newTitle = firstUserMessage.substring(0, 30) + (firstUserMessage.length > 30 ? '...' : '');
                 else if (isImageOnly) newTitle = "Image Input";
                 chatHistory[activeChatId].title = newTitle;
                 saveHistoryToStorage();
                 renderChatHistory();
             }
        }
        function showLoading() {
            const loadingMessage = document.createElement('div');
            loadingMessage.className = 'message-group ai';
            loadingMessage.id = 'loading-indicator';
            loadingMessage.innerHTML = `<div class="avatar avatar-ai">🤖</div><div class="bubble"><div class="typing-indicator"><span></span><span></span><span></span></div></div>`;
            chatBox.appendChild(loadingMessage);
            setTimeout(() => chatBox.scrollTop = chatBox.scrollHeight, 50);
            return loadingMessage;
        }
        async function callApi(endpoint, body) {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });
            const responseBody = await response.text();
            if (!response.ok) {
                 try { const errorJson = JSON.parse(responseBody); throw new Error(errorJson.response || errorJson.message || `Server error ${response.status}`); }
                 catch (e) { throw new Error(responseBody || `Server error ${response.status}`); }
            }
            try { return JSON.parse(responseBody); }
            catch (e) { throw new Error("Invalid JSON response from server."); }
        }
        function createGifFromFrames(frames) {
             return new Promise((resolve, reject) => {
                 if (!frames || frames.length === 0) return reject(new Error("No frames provided to create GIF."));
                 const gif = new GIF({ workers: 2, quality: 10, width: 512, height: 512, workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js' });
                 const imagePromises = frames.map(frameData => new Promise(resolveImg => {
                     const img = new Image(); img.crossOrigin = "anonymous";
                     img.src = frameData;
                     img.onload = () => resolveImg(img);
                     img.onerror = () => { console.warn("Failed to load a frame"); resolveImg(null); };
                 }));
                 Promise.all(imagePromises).then(imageElements => {
                     const validImages = imageElements.filter(img => img);
                     if (validImages.length === 0) return reject(new Error("Could not load any valid frames."));
                     validImages.forEach(img => gif.addFrame(img, { delay: 100 }));
                     gif.on('finished', (blob) => resolve(URL.createObjectURL(blob)));
                     gif.render();
                 }).catch(reject);
             });
        }

        // === Logic Mode Selector Mới ===
        function toggleModeExpand(forceClose = false) {
            isModeExpanded = forceClose ? false : !isModeExpanded;
            if (isModeExpanded) {
                hiddenModesContainer.classList.add('open');
                expandBtn.querySelector('#expand-icon').textContent = '—';
            } else {
                hiddenModesContainer.classList.remove('open');
                expandBtn.querySelector('#expand-icon').textContent = '+';
            }
        }
        expandBtn.addEventListener('click', (e) => { e.preventDefault(); toggleModeExpand(); });
        function handleModeSelection(selectedMode) {
             const previousMode = currentChatMode;
             modeButtons.forEach(btn => btn.classList.remove('active'));
             const newActiveBtn = document.querySelector(`.mode-btn[data-mode="${selectedMode}"]`);
             if (newActiveBtn) newActiveBtn.classList.add('active');
             else document.querySelector(`.mode-btn[data-mode="chat"]`)?.classList.add('active');
             if (selectedMode !== 'chat' && isModeExpanded) toggleModeExpand(true);
             currentChatMode = selectedMode;

             switch(currentChatMode) {
                 case 'persona':
                     mainInput.placeholder = currentPersonaDesc ? `Chatting as ${currentPersonaDesc} (gõ !clearpersona để reset)...` : 'Nhập vai trò bạn muốn tôi đóng (vd: Einstein)...';
                     if ((previousMode !== 'persona' || !currentPersonaDesc) && activeChatId) {
                         const lastMsg = chatHistory[activeChatId]?.messages.slice(-1)[0];
                         if (!lastMsg || !lastMsg.content.includes("Nào, hãy cho tôi biết")) {
                            if (document.querySelector('.welcome-message')) document.querySelector('.welcome-message').remove();
                            appendMessage("Nào, hãy cho tôi biết bạn muốn tôi trở thành ai! (vd: 'Albert Einstein', 'chuyên gia marketing', 'em gái của tôi')...", 'ai', false);
                         }
                     }
                     break;
                 case 'summarize_youtube': mainInput.placeholder = 'Dán URL video YouTube (kèm ID video)...'; break;
                 case 'analyze_stock': mainInput.placeholder = 'Nhập mã chứng khoán (vd: AAPL, VNM)...'; break;
                 case 'edit_image': mainInput.placeholder = 'Tải ảnh & mô tả chỉnh sửa (vd: "biến anh ấy thành người máy")...'; break;
                 case 'notetaker': mainInput.placeholder = 'Dán văn bản cần ghi chú...'; break;
                 case 'marketing': mainInput.placeholder = 'Nhập chủ đề/sản phẩm cần viết content...'; break;
                 case 'music': mainInput.placeholder = 'Nhập chủ đề/tâm trạng cho bài nhạc (Chỉ tạo lời & hợp âm, không tạo âm thanh)...'; break;
                 default: mainInput.placeholder = 'Hỏi tôi bất cứ điều gì...';
             }
             const fileLabel = fileInput.labels[0];
             const allowFile = ['chat', 'math', 'edit_image', 'persona'].includes(currentChatMode);
             if (fileLabel) fileLabel.style.display = allowFile ? 'flex' : 'none';
             if (!allowFile) { uploadedFile = null; previewContainer.innerHTML = ''; fileInput.value = ''; }
        }
        modeButtons.forEach(button => { button.addEventListener('click', () => { if (!button.disabled) handleModeSelection(button.dataset.mode); }); });

        // --- Main Send Function ---
        const handleSendMessage = async () => {
             if (!checkUsageLimit()) return;
             const prompt = mainInput.value.trim(); const image = uploadedFile;
             
             // 📌 FIX 1: Thêm lệnh xóa vai trò (clear persona)
             if (currentChatMode === 'persona' && currentPersonaDesc && prompt.toLowerCase().includes('!clearpersona')) {
                 currentPersonaDesc = '';
                 localStorage.removeItem('ai_pro_persona_desc');
                 appendMessage("Đã xóa vai trò nhập vai. Tôi đã trở lại thành trợ lý AI thông thường.", 'ai', true);
                 mainInput.value = '';
                 mainInput.placeholder = 'Nhập vai trò bạn muốn tôi đóng (vd: Einstein)...';
                 return;
             }

             if (currentChatMode === 'persona' && !currentPersonaDesc) {
                  if (!prompt) { alert("Vui lòng nhập vai trò."); return; }
                  setPersona(prompt); mainInput.value = ''; mainInput.placeholder = `Chatting as ${currentPersonaDesc} (gõ !clearpersona để reset)...`; return;
             }
             if (currentChatMode === 'edit_image' && !image) { alert("Vui lòng tải ảnh."); return; }
             if (!prompt && currentChatMode === 'analyze_stock') { alert("Vui lòng nhập mã chứng khoán."); return; }
             if (!prompt && currentChatMode === 'summarize_youtube') { alert("Vui lòng dán URL YouTube."); return; }
             if (!prompt && currentChatMode === 'notetaker') { alert("Vui lòng dán văn bản."); return; }
             if (!prompt && currentChatMode === 'marketing') { alert("Vui lòng nhập chủ đề marketing."); return; }
             if (!prompt && currentChatMode === 'music') { alert("Vui lòng nhập chủ đề cho bài nhạc."); return; }
             if (!prompt && !image && !['chat', 'math', 'persona'].includes(currentChatMode)) { return; }

             if (document.querySelector('.welcome-message')) document.querySelector('.welcome-message').remove();
             let userMsgContent = prompt;
             if (image && ['chat', 'math', 'edit_image', 'persona'].includes(currentChatMode)) {
                 userMsgContent = `<img src="${image}" style="max-height:100px; border-radius:8px; margin-bottom:5px; display:block;" alt="uploaded"><p>${prompt || 'Analyze/Edit'}</p>`;
             }
             appendMessage(userMsgContent || (image ? "[Image]" : "[Empty]"), 'user');
             updateChatTitle(prompt, !prompt && !!image);
             const loadingBubbleGroup = showLoading();
             const currentPromptValue = prompt; const currentImageValue = image;
             mainInput.value = ''; previewContainer.innerHTML = ''; uploadedFile = null; fileInput.value = ''; mainInput.style.height = 'auto';

            try {
                let responseData; let finalContent = ''; let isSummaryResult = false;
                let systemInstruction = getSystemInstruction(languageSelect.value);

                switch (currentChatMode) {
                    case 'image': responseData = await callApi('/api/pollinations-image', { prompt: currentPromptValue }); finalContent = `<img src="${responseData.imageUrl}" class="generated-image">`; break;
                    case 'edit_image':
                        // 📌 FIX 4: Sửa ảnh (Image Editing) - Đảm bảo hình ảnh được trả về
                        loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating edit description...';
                        // System instruction cứng để đảm bảo prompt đầu ra là text tiếng Anh thuần
                        const editImageInstruction = `Analyze the uploaded image and the user's text description. Your task is to generate ONLY the best, most detailed English prompt (max 30 words) for a powerful text-to-image model (like Midjourney or DALL-E) to create the *edited* image. DO NOT add any surrounding text, just the prompt.`;
                        
                        const descRes = await callApi('/api/edit-image', { message: currentPromptValue, image: currentImageValue, systemInstruction: editImageInstruction });
                        const newPrompt = descRes.response; 
                        
                        if (newPrompt.startsWith('❌')) throw new Error(newPrompt);
                        
                        loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating edited image...';
                        const imgRes = await callApi('/api/pollinations-image', { prompt: newPrompt });

                        // Kiểm tra lại URL hình ảnh trước khi hiển thị
                        if (!imgRes.imageUrl || imgRes.imageUrl.includes('Could not create image')) {
                            throw new Error("Image generation failed or returned an invalid URL.");
                        }

                        // Xây dựng finalContent với cả prompt và hình ảnh
                        finalContent = `<p><strong>Based on:</strong> <mark class="highlight">${newPrompt}</mark></p><img src="${imgRes.imageUrl}" class="generated-image">`;
                        
                        break;
                    case 'math': systemInstruction = `Solve math in Vietnamese...`; responseData = await callApi('/api/math', { question: currentPromptValue, image: currentImageValue, systemInstruction }); finalContent = responseData.response; break;
                    case 'summarize_youtube': responseData = await callApi('/api/summarize-youtube', { youtubeUrl: currentPromptValue }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'notetaker': systemInstruction = "You are a notetaker..."; responseData = await callApi('/api/summarize-text', { textToSummarize: currentPromptValue, systemInstruction }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'analyze_stock': responseData = await callApi('/api/analyze-stock', { stockSymbol: currentPromptValue }); finalContent = responseData.response; break;
                    case 'marketing': responseData = await callApi('/api/marketing-content', { marketingTopic: currentPromptValue, language: languageSelect.value }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'music': responseData = await callApi('/api/music-generation', { musicTopic: currentPromptValue, language: languageSelect.value }); 
                        // FIX 1: Nhạc (Giải thích giới hạn)
                        finalContent = `**Ghi chú:** Gemini AI chỉ có thể tạo lời và hợp âm, không thể tạo ra file âm thanh.\n\n${responseData.response}`; 
                        break;
                    case 'video':
                         loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating frames...';
                         responseData = await callApi('/api/pollinations-frames', { prompt: currentPromptValue });
                         if (!responseData.frames || !Array.isArray(responseData.frames) || responseData.frames.length === 0) { throw new Error(responseData.message || 'Video frame gen failed.'); }
                         loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Rendering GIF...';
                         const videoUrl = await createGifFromFrames(responseData.frames);
                         finalContent = `<img src="${videoUrl}" class="generated-video">`; break;
                    case 'persona': case 'chat':
                         responseData = await callApi('/api/chat', { message: currentPromptValue, image: currentImageValue, language: languageSelect.value, systemInstruction: systemInstruction });
                         finalContent = responseData.response; break;
                }

                const aiBubbleElement = loadingBubbleGroup.querySelector('.bubble');
                
                // Lưu nội dung thô hoặc HTML tùy theo chế độ
                if (isSummaryResult && !finalContent.startsWith('❌')) {
                    // Xử lý nội dung tóm tắt để thêm nút hành động
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = finalContent;
                    const summaryText = tempDiv.textContent || tempDiv.innerText || "";
                    
                    aiBubbleElement.innerHTML = finalContent;
                    addSummaryActions(aiBubbleElement, summaryText);
                    saveMessage(finalContent, 'ai');

                } else if (currentChatMode === 'math') { 
                    // Xử lý MathJax
                    aiBubbleElement.innerHTML = finalContent;
                    MathJax.typesetPromise([aiBubbleElement]); 
                    saveMessage(finalContent, 'ai');
                    
                } else {
                    // Nội dung thường, chỉ gán và lưu
                    aiBubbleElement.innerHTML = finalContent;
                    saveMessage(finalContent, 'ai');
                }
                
                incrementUsageCount(); // Tăng XP và lượt dùng

            } catch (error) {
                loadingBubbleGroup.querySelector('.bubble').innerHTML = `❌ Error: ${error.message}`;
                saveMessage(loadingBubbleGroup.querySelector('.bubble').innerHTML, 'ai');
            }
        };

        // --- Event Listeners and Initializers ---
        sendBtn.addEventListener('click', handleSendMessage);
        newChatBtn.addEventListener('click', startNewChat);
        menuBtn.addEventListener('click', () => { sidebar.classList.toggle('open'); });
        settingsBtn.addEventListener('click', () => { settingsModal.style.display = settingsModal.style.display === 'block' ? 'none' : 'block'; });
        document.addEventListener('click', (e) => {
             if (sidebar.classList.contains('open') && !sidebar.contains(e.target) && !menuBtn.contains(e.target)) { sidebar.classList.remove('open'); }
             if (settingsModal.style.display === 'block' && !settingsBtn.contains(e.target) && !settingsModal.contains(e.target)) { settingsModal.style.display = 'none'; }
        });
        mainInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
        mainInput.addEventListener('input', () => { mainInput.style.height = 'auto'; mainInput.style.height = (mainInput.scrollHeight) + 'px'; });
        fileInput.addEventListener('change', (event) => {
             const file = event.target.files[0];
             if (file) {
                 if (file.size > 5 * 1024 * 1024) { alert("File size exceeds 5MB limit."); fileInput.value = ''; return; }
                 const reader = new FileReader();
                 reader.onload = (e) => { uploadedFile = e.target.result; previewContainer.innerHTML = `<img src="${uploadedFile}" alt="Preview" class="rounded-lg shadow">`; };
                 reader.readAsDataURL(file);
             }
         });

        function initializeApp() {
            playIntro(); // Bật lại Intro
            loadHistoryFromStorage();
            if (Object.keys(chatHistory).length === 0) startNewChat();
            else loadChat(Object.keys(chatHistory).sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]))[0] || Object.keys(chatHistory)[0]);
            renderChatHistory();
            loadUserData(); // Load giới hạn và gamification
            const savedLang = localStorage.getItem('chat_language') || 'vi';
            languageSelect.value = savedLang;
            handleModeSelection('chat');
        }
        initializeApp();
    });
    </script>
</body>
</html>