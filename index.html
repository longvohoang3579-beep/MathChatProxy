<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Assistant Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true });</script>
    <style>
        /* --- Gi·ªØ nguy√™n to√†n b·ªô CSS t·ª´ file doc --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        :root { --primary-yellow: #facc15; --dark-bg: #0a0a0c; --main-bg: #141417; --input-bg: #1f1f23; --bubble-ai-bg: #2d2d33; --bubble-user-bg: linear-gradient(135deg, #5e5ce6, #2563eb); --text-primary: #e4e4e7; --text-secondary: #a1a1aa; }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: var(--main-bg); } ::-webkit-scrollbar-thumb { background-color: #4a4a52; border-radius: 10px; border: 2px solid var(--main-bg); }
        body { background-color: var(--dark-bg); background-image: radial-gradient(circle at 1% 1%, rgba(255, 255, 255, 0.04) 1px, transparent 0), radial-gradient(circle at 99% 99%, rgba(255, 255, 255, 0.04) 1px, transparent 0); background-size: 50px 50px; color: var(--text-primary); font-family: 'Inter', sans-serif; margin: 0; padding: 0; overflow: hidden; }
        #intro-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: var(--dark-bg); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 1; transition: opacity 1s ease-in-out 6s; }
        .intro-container { position: relative; display: flex; align-items: center; justify-content: center; }
        #intro-yellow-flash { position: absolute; width: 100vw; height: 100vh; background-color: var(--primary-yellow); animation: yellowFlash 2s ease-in-out forwards; } @keyframes yellowFlash { 0% { transform: scale(0); border-radius: 50%; } 50% { transform: scale(1); border-radius: 0; } 100% { transform: scale(1); border-radius: 0; opacity: 0; } }
        #intro-text { position: relative; color: #fff; font-size: 3rem; font-weight: bold; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); opacity: 0; animation: logoAnimate 4s ease-in-out 1.5s forwards; }
        #intro-text::after { content: ''; position: absolute; top: 0; left: -10%; width: 20%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent); transform: skewX(-25deg); opacity: 0; animation: shine 1.5s ease-in-out 3s forwards; }
        #intro-burst { position: absolute; width: 1px; height: 1px; background: white; border-radius: 50%; opacity: 0; animation: burst 1s ease-out 5s forwards; } @keyframes logoAnimate { 0% { opacity: 0; transform: scale(2); } 25% { opacity: 1; transform: scale(1); } 75% { opacity: 1; transform: scale(1); } 100% { opacity: 1; transform: scale(1.1); } } @keyframes shine { 0% { left: -10%; opacity: 1; } 100% { left: 110%; opacity: 1; } } @keyframes burst { from { opacity: 1; transform: scale(0); box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px var(--primary-yellow), 0 0 30px var(--primary-yellow); } to { opacity: 0; transform: scale(200); box-shadow: 0 0 50px #fff, 0 0 75px var(--primary-yellow); } }
        #app-wrapper { display: flex; height: 100vh; opacity: 0; transition: opacity 0.5s ease-in; position: relative; z-index: 1; }
        mark.highlight { background-color: var(--primary-yellow); color: black; font-weight: bold; padding: 2px 5px; border-radius: 4px; }
        #sidebar { width: 260px; background-color: var(--dark-bg); border-right: 1px solid #27272a; padding: 1rem; display: flex; flex-direction: column; transform: translateX(-100%); transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1); position: fixed; left: 0; top: 0; height: 100%; z-index: 100; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #sidebar.open { transform: translateX(0); }
        .social-login-container { display: flex; gap: 0.75rem; align-items: center; } .social-btn { background-color: #2d2d33; border: 1px solid #444; color: white; padding: 0.5rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s; width: 36px; height: 36px; font-size: 1.1rem; } .social-btn:hover { background-color: #444; border-color: var(--primary-yellow); }
        #new-chat-btn { background-color: transparent; border: 1px solid var(--primary-yellow); color: var(--primary-yellow); width: 100%; text-align: center; transition: all 0.2s ease; margin-top: 1rem; } #new-chat-btn:hover { background-color: var(--primary-yellow); color: var(--dark-bg); }
        .history-item { padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: all 0.2s; border-left: 3px solid transparent; } .history-item:hover { background-color: var(--main-bg); color: var(--text-primary); } .history-item.active { background-color: #27272a; color: white; font-weight: 500; border-left-color: var(--primary-yellow); }
        #chat-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; max-width: 900px; margin: 0 auto; padding: 1rem; transition: margin-left 0.4s cubic-bezier(0.25, 1, 0.5, 1); margin-left: auto; margin-right: auto; position: relative; }
        #sidebar.open ~ #chat-container { margin-left: 260px; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 0 0.5rem; position: relative; z-index: 50; }
        .menu-btn, #settings-btn { font-size: 1.8rem; cursor: pointer; color: var(--primary-yellow); z-index: 51; transition: transform 0.2s; }
        .menu-btn:hover, #settings-btn:hover { transform: scale(1.1); }
        .chat-box { background: transparent; padding: 1rem; flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; scroll-behavior: smooth; margin-top: 1rem; gap: 1rem; }
        .message-group { display: flex; gap: 12px; max-width: 90%; } .message-group.user { align-self: flex-end; flex-direction: row-reverse; } .message-group.ai { align-self: flex-start; }
        .avatar { width: 32px; height: 32px; border-radius: 50%; background: #444; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-top: 4px; } .avatar-user { background: #5e5ce6; color: white; } .avatar-ai { background: var(--primary-yellow); color: #111; }
        @keyframes fadeInBubble { from { opacity: 0; transform: translateY(10px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } } .bubble { padding: 12px 18px; border-radius: 18px; line-height: 1.6; word-wrap: break-word; white-space: pre-wrap; animation: fadeInBubble 0.3s ease-out forwards; box-shadow: 0 4px 15px rgba(0,0,0,0.2); } .user .bubble { background: var(--bubble-user-bg); color: white; border-bottom-right-radius: 4px; } .ai .bubble { background: var(--bubble-ai-bg); color: var(--text-primary); border-bottom-left-radius: 4px; }
        .welcome-message { text-align: center; color: var(--text-secondary); padding: 2rem 1rem; animation: fadeInBubble 0.5s ease; } .welcome-message h2 { font-size: 1.8rem; font-weight: bold; color: var(--text-primary); }
        .typing-indicator { display: flex; align-items: center; gap: 5px; } .typing-indicator span { width: 8px; height: 8px; background-color: #777; border-radius: 50%; animation: typing 1s infinite; } .typing-indicator span:nth-child(2) { animation-delay: 0.2s; } .typing-indicator span:nth-child(3) { animation-delay: 0.4s; } @keyframes typing { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        pre { background-color: #0d1117; color: #c9d1d9; padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid #30363d; font-size: 0.9em; } code { font-family: 'Courier New', Courier, monospace; }
        .input-area { margin-top: 1rem; padding: 0.5rem; background: var(--main-bg); border-radius: 1rem; box-shadow: 0 -5px 20px rgba(0,0,0,0.2); }
        .mode-selector { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; justify-content: center; position: relative; }
        .mode-btn { background: #2d3748; padding: 0.5rem 1rem; border-radius: 20px; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s; border: 2px solid transparent; font-size: 0.9rem; color: var(--text-secondary); } .mode-btn:hover:not(:disabled) { background: #4a5568; color: var(--text-primary); } .mode-btn.active { border-color: var(--primary-yellow); background-color: #374151; color: var(--primary-yellow); font-weight: 500; } .mode-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .hidden-modes { position: absolute; bottom: 100%; right: 0; left: 0; background: var(--main-bg); border-radius: 10px; padding: 10px; margin-bottom: 8px; box-shadow: 0 -5px 15px rgba(0,0,0,0.3); display: flex; flex-wrap: wrap; gap: 8px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, border-width 0.3s ease-in-out; border: 1px solid transparent; z-index: 10; justify-content: center; }
        .hidden-modes.open { max-height: 300px; border: 1px solid #333; padding: 10px; }
        .mode-selector > .mode-btn { padding: 0.5rem 1.5rem; }
        #mode-expand-btn { background: #2d3748; color: var(--primary-yellow); border-radius: 50%; width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; line-height: 1; transition: transform 0.3s ease; z-index: 11; }
        #mode-expand-btn:hover { background: #4a5568; transform: rotate(90deg); }
        .input-row { display: flex; align-items: flex-end; gap: 0.75rem; background: var(--input-bg); padding: 0.5rem; border-radius: 0.75rem; border: 1px solid #333; transition: border-color 0.2s; } .input-row:focus-within { border-color: var(--primary-yellow); }
        textarea:disabled { opacity: 0.6; cursor: not-allowed; }
        .icon-btn:disabled, .send-btn:disabled { opacity: 0.5; cursor: not-allowed !important; transform: none !important; background-color: #2d3748 !important; color: var(--text-secondary) !important; }
        textarea { width: 100%; padding: 0.6rem; border-radius: 0.5rem; background: transparent; border: none; color: white; resize: none; outline: none; max-height: 200px; font-size: 1rem; line-height: 1.5; }
        .icon-btn, .send-btn { background: transparent; padding: 10px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: none; color: var(--text-secondary); flex-shrink: 0; } .icon-btn:hover:not(:disabled) { color: var(--primary-yellow); background: #374151; } .send-btn { background: var(--primary-yellow); color: var(--dark-bg); } .send-btn:hover:not(:disabled) { transform: scale(1.1); }
        .pending-preview { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; padding: 0.5rem; } .pending-preview img { width: 60px; height: 60px; object-fit: cover; border-radius: 8px; border: 2px solid #475569; }
        img.generated-image, .generated-video { border-radius: 12px; max-width: 100%; margin-top: 1rem; display: block; max-height: 400px; margin-left: auto; margin-right: auto; }
        #settings-modal { position: absolute; top: 3rem; right: 1rem; width: 200px; background: var(--main-bg); border: 1px solid var(--primary-yellow); border-radius: 0.75rem; padding: 1rem; display: none; z-index: 100; }
        #voice-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); z-index: 1500; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; }
        .mic-wave-container { width: 200px; height: 200px; border-radius: 50%; display: flex; align-items: center; justify-content: center; position: relative; } .mic-wave-container.listening .wave { animation: ripple 1.5s ease-out infinite; } .mic-wave-container .wave { position: absolute; width: 100%; height: 100%; border: 4px solid var(--primary-yellow); border-radius: 50%; opacity: 0; } .mic-wave-container .wave:nth-child(2) { animation-delay: 0.3s; } .mic-wave-container .wave:nth-child(3) { animation-delay: 0.6s; } @keyframes ripple { from { transform: scale(0.5); opacity: 1; } to { transform: scale(1.5); opacity: 0; } }
        .mic-icon { font-size: 3rem; color: #111; background-color: var(--primary-yellow); border-radius: 50%; padding: 20px; z-index: 10; cursor: pointer; }
        #limit-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 2000; display: none; align-items: center; justify-content: center; flex-direction: column; } #password-form { background: var(--main-bg); padding: 2.5rem; border-radius: 1rem; text-align: center; border: 3px solid var(--primary-yellow); box-shadow: 0 0 30px rgba(250, 204, 21, 0.3); }
        .summary-actions { margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 0.5rem; border-top: 1px solid #444; padding-top: 0.75rem; }
        .summary-btn { background-color: #374151; color: #e5e7eb; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.8rem; cursor: pointer; transition: background-color 0.2s; border: none; }
        .summary-btn:hover:not(:disabled) { background-color: #4b5563; }
        .summary-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        /* --- TH√äM M·ªöI: CSS cho Gamification --- */
        #gamification-stats { padding: 0.5rem 0.25rem; margin-top: 1rem; border-top: 1px solid #27272a; }
        .stat-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .stat-item span { font-size: 0.9rem; color: var(--text-secondary); }
        .stat-item .value { font-weight: bold; color: var(--text-primary); }
        .xp-bar-container { background-color: #2d2d33; border-radius: 99px; height: 10px; overflow: hidden; width: 100%; }
        .xp-bar { background-color: var(--primary-yellow); height: 100%; width: 0%; transition: width 0.5s ease; }
        /* --- H·∫øt CSS --- */
    </style>
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
</head>
<body>
    <div id="intro-screen">
        <div class="intro-container">
            <div id="intro-yellow-flash"></div>
            <div id="intro-text">AI Assistant Pro</div>
            <div id="intro-burst"></div>
        </div>
    </div>
    <audio id="intro-audio" src="data:audio/mpeg;base64,..."></audio>

    <div id="limit-overlay">
        <div id="password-form">
             <h2 class="text-2xl font-bold mb-4 text-yellow-500">ƒê√£ h·∫øt l∆∞·ª£t s·ª≠ d·ª•ng mi·ªÖn ph√≠ h√¥m nay!</h2>
             <p id="limit-message" class="mb-6 text-gray-300">Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ m·ªü kh√≥a s·ª≠ d·ª•ng kh√¥ng gi·ªõi h·∫°n:</p>
             <input type="password" id="password-input" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-yellow-500 outline-none" placeholder="M·∫≠t kh·∫©u">
             <button id="unlock-btn" class="mt-4 p-3 bg-yellow-500 text-black font-bold rounded-lg w-full hover:bg-yellow-600 transition">M·ªü kh√≥a V√¥ H·∫°n</button>
             <p id="password-message" class="mt-3 text-red-500 hidden"></p>
        </div>
    </div>
     <div id="voice-overlay">
        <div class="mic-wave-container" id="mic-wave">
            <div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="mic-icon" id="voice-mic-icon">üé§</div>
        </div>
        <p id="voice-status" class="mt-6 text-xl font-medium text-yellow-500">Nh·∫•n Mic ƒë·ªÉ B·∫Øt ƒë·∫ßu N√≥i...</p>
        <button id="voice-close-btn" class="mt-10 p-3 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition">T·∫Øt Ch·ª©c NƒÉng Gi·ªçng N√≥i</button>
    </div>

    <div id="app-wrapper">
        <aside id="sidebar">
             <div class="social-login-container mb-4">
                 <button onclick="alert('ƒêƒÉng nh·∫≠p Google ƒëang ph√°t tri·ªÉn!')" class="social-btn" title="ƒêƒÉng nh·∫≠p v·ªõi Google"><i class="fab fa-google"></i></button>
                 <button onclick="alert('ƒêƒÉng nh·∫≠p Facebook ƒëang ph√°t tri·ªÉn!')" class="social-btn" title="ƒêƒÉng nh·∫≠p v·ªõi Facebook"><i class="fab fa-facebook-f"></i></button>
                 <button onclick="alert('ƒêƒÉng nh·∫≠p GitHub ƒëang ph√°t tri·ªÉn!')" class="social-btn" title="ƒêƒÉng nh·∫≠p v·ªõi GitHub"><i class="fab fa-github"></i></button>
             </div>
             <button id="new-chat-btn" class="p-3 rounded-lg font-bold">Ôºã New Conversation</button>
             
             <div id="gamification-stats">
                 <h3 class="text-gray-400 text-sm font-bold mb-2 uppercase">Ti·∫øn ƒë·ªô c·ªßa b·∫°n</h3>
                 <div class="stat-item">
                     <span>üî• Chu·ªói ng√†y (Streak):</span>
                     <span id="streak-counter" class="value">0 ng√†y</span>
                 </div>
                 <div class="stat-item">
                     <span id="level-counter">C·∫•p 0</span>
                     <span id="xp-counter" class="value">0/100 XP</span>
                 </div>
                 <div class="xp-bar-container">
                     <div id="xp-bar" class="xp-bar"></div>
                 </div>
             </div>
             
             <h2 class="text-gray-400 text-sm font-bold mt-6 mb-2 uppercase">History</h2>
             <div id="chat-history" class="flex-grow overflow-y-auto"></div>
             <div id="usage-counter" class="text-center text-sm text-gray-400 mt-auto pt-4 border-t border-gray-700">Loading usage...</div>
        </aside>

        <main id="chat-container">
            <div class="header relative">
                 <div id="menu-btn" class="menu-btn">‚ò∞</div>
                 <div class="flex-grow"></div>
                 <div id="settings-btn">‚öôÔ∏è</div>
                 <div id="settings-modal">
                     <label class="block mb-2">Chat Language:</label>
                     <select id="language-select" class="w-full p-2 rounded bg-gray-800 text-white">
                         <option value="vi">Ti·∫øng Vi·ªát</option>
                         <option value="en">English</option>
                         <option value="zh-CN">ÁÆÄ‰Ωì‰∏≠Êñá</option>
                     </select>
                 </div>
            </div>
            <div class="chat-box" id="chatBox"></div>
            <div class="input-area">
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="chat" title="Tr√≤ chuy·ªán"><span>üí¨ Chat</span></button>
                    <button id="mode-expand-btn" class="icon-btn" title="Ch·ª©c nƒÉng m·ªü r·ªông">
                        <span id="expand-icon">+</span>
                    </button>
                    <div id="hidden-modes" class="hidden-modes">
                        <button class="mode-btn" data-mode="persona" title="Nh·∫≠p vai nh√¢n v·∫≠t"><span>üé≠ Nh·∫≠p Vai</span></button>
                        <button class="mode-btn" data-mode="image" title="T·∫°o ·∫£nh"><span>üñºÔ∏è T·∫°o ·∫¢nh</span></button>
                        <button class="mode-btn" data-mode="math" title="Gi·∫£i to√°n"><span>üßÆ Gi·∫£i To√°n</span></button>
                        <button class="mode-btn" data-mode="video" title="T·∫°o video"><span>üé• T·∫°o Video</span></button>
                        <button class="mode-btn" data-mode="edit_image" title="Ch·ªânh s·ª≠a ·∫£nh"><span>‚úçÔ∏è S·ª≠a ·∫¢nh</span></button>
                        <button class="mode-btn" data-mode="summarize_youtube" title="T√≥m t·∫Øt YouTube"><span>‚ñ∂Ô∏è T√≥m T·∫Øt YT</span></button>
                        <button class="mode-btn" data-mode="notetaker" title="Ghi ch√∫ vƒÉn b·∫£n"><span>üìù Ghi Ch√∫</span></button>
                        <button class="mode-btn" data-mode="analyze_stock" title="Ph√¢n t√≠ch Ch·ª©ng kho√°n"><span>üìà Ch·ª©ng Kho√°n</span></button>
                        <button class="mode-btn" data-mode="marketing" title="Vi·∫øt Content Marketing"><span>üì¢ Marketing</span></button>
                        <button class="mode-btn" data-mode="music" title="S√°ng t√°c Nh·∫°c (L·ªùi & H·ª£p √¢m)"><span>üéµ T·∫°o Nh·∫°c</span></button>
                    </div>
                </div>
                <div class="pending-preview" id="previewContainer"></div>
                <div class="input-row">
                    <label class="icon-btn" for="fileInput" title="T·∫£i ·∫£nh">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M6.5 12.5a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM.5 4.5A.5.5 0 0 1 1 4h14a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5zM3 8.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 8.5z"/></svg>
                    </label>
                    <input type="file" id="fileInput" accept="image/*" hidden />
                    <button id="voiceBtn" class="icon-btn" title="Tr√≤ chuy·ªán b·∫±ng gi·ªçng n√≥i">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/></svg>
                    </button>
                    <textarea id="mainInput" rows="1" placeholder="Ask me anything..."></textarea>
                    <button id="sendBtn" class="send-btn" title="G·ª≠i">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="22" height="22" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Khai b√°o bi·∫øn DOM ---
        const getEl = (id) => document.getElementById(id);
        const introScreen = getEl('intro-screen'), appWrapper = getEl('app-wrapper'), introAudio = getEl('intro-audio');
        const sidebar = getEl('sidebar'), menuBtn = getEl('menu-btn'), chatContainer = getEl('chat-container'), chatBox = getEl('chatBox'), mainInput = getEl('mainInput'), sendBtn = getEl('sendBtn'), fileInput = getEl('fileInput'), previewContainer = getEl('previewContainer'), languageSelect = getEl('language-select'), settingsBtn = getEl('settings-btn'), settingsModal = getEl('settings-modal'), newChatBtn = getEl('new-chat-btn'), chatHistoryContainer = getEl('chat-history');
        const voiceBtn = getEl('voiceBtn'), voiceOverlay = getEl('voice-overlay'), voiceCloseBtn = getEl('voice-close-btn'), voiceStatus = getEl('voice-status'), voiceMicIcon = getEl('voice-mic-icon'), micWave = getEl('mic-wave');
        const limitOverlay = getEl('limit-overlay'), passwordInput = getEl('password-input'), unlockBtn = getEl('unlock-btn'), passwordMessage = getEl('password-message');
        const modeButtons = document.querySelectorAll('.mode-selector .mode-btn');
        const expandBtn = getEl('mode-expand-btn');
        const hiddenModesContainer = getEl('hidden-modes');
        const usageCounterEl = getEl('usage-counter');
        const fileInputLabel = fileInput.labels[0];
        // DOM m·ªõi cho Gamification
        const streakCounterEl = getEl('streak-counter');
        const levelCounterEl = getEl('level-counter');
        const xpCounterEl = getEl('xp-counter');
        const xpBarEl = getEl('xp-bar');


        let currentChatMode = 'chat', uploadedFile = null, chatHistory = {}, activeChatId = null, isRecording = false;
        let currentPersonaDesc = localStorage.getItem('ai_pro_persona_desc') || '';
        let isModeExpanded = false;

        // === Logic Gi·ªõi H·∫°n H√†ng Ng√†y & Gamification (G·ªôp chung) ===
        const MAX_DAILY_USES = 20;
        const UNLOCK_PASSWORD = "Hoang1082009@";
        // D√πng m·ªôt object duy nh·∫•t ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu ng∆∞·ªùi d√πng
        let userData = {
            count: 0,
            date: '',
            unlocked: false,
            streak: 0,
            lastStreakDate: '',
            xp: 0
        };
        
        function getTodayString() { return new Date().toDateString(); }
        function getYesterdayString() { return new Date(Date.now() - 86400000).toDateString(); }

        function loadUserData() {
            const today = getTodayString();
            const yesterday = getYesterdayString();
            const storedData = JSON.parse(localStorage.getItem('ai_pro_userdata_v1')) || {};

            // G·ªôp d·ªØ li·ªáu ƒë√£ l∆∞u
            userData = { ...userData, ...storedData };

            // 1. Logic Gi·ªõi h·∫°n l∆∞·ª£t d√πng
            if (userData.unlocked) {
                userData.date = today;
            } else if (userData.date !== today) {
                userData.count = 0; // Reset l∆∞·ª£t d√πng
                userData.date = today;
            }
            
            // 2. Logic Gamification (Streak)
            if (userData.lastStreakDate === yesterday) {
                // Ti·∫øp t·ª•c streak
                userData.streak++;
                userData.lastStreakDate = today;
            } else if (userData.lastStreakDate !== today) {
                // B·∫Øt ƒë·∫ßu streak m·ªõi (ho·∫∑c reset)
                userData.streak = 1;
                userData.lastStreakDate = today;
            }
            // N·∫øu lastStreakDate == today, kh√¥ng l√†m g√¨ c·∫£
            
            saveUserData(); // L∆∞u l·∫°i (ƒë·∫∑c bi·ªát l√† date m·ªõi v√† streak)
            checkUsageLimit(); // Ki·ªÉm tra ngay khi t·∫£i
        }
        function saveUserData() {
            localStorage.setItem('ai_pro_userdata_v1', JSON.stringify(userData));
            updateUsageDisplay();
            updateGamificationUI();
        }
        function updateUsageDisplay() {
            if (!usageCounterEl) return;
            usageCounterEl.innerHTML = userData.unlocked
                ? `<span class="text-green-400 font-bold">V√¥ h·∫°n</span> | <a href="#" id="lock-limit" class="text-red-400 hover:text-red-300">Kh√≥a L·∫°i</a>`
                : `C√≤n l·∫°i: <span class="text-yellow-400 font-bold">${Math.max(0, MAX_DAILY_USES - userData.count)}</span> l∆∞·ª£t`;
            document.getElementById('lock-limit')?.addEventListener('click', (e) => {
                e.preventDefault();
                if (confirm("B·∫°n ch·∫Øc ch·∫Øn mu·ªën kh√≥a l·∫°i gi·ªõi h·∫°n s·ª≠ d·ª•ng kh√¥ng?")) {
                    userData.unlocked = false; userData.count = 0; saveUserData(); checkUsageLimit();
                }
            });
        }
        function updateGamificationUI() {
            if (!streakCounterEl || !xpCounterEl || !xpBarEl || !levelCounterEl) return;
            
            const level = Math.floor(userData.xp / 100);
            const xpForNextLevel = 100;
            const currentXPInLevel = userData.xp % xpForNextLevel;
            
            streakCounterEl.textContent = `${userData.streak} ng√†y`;
            levelCounterEl.textContent = `C·∫•p ${level}`;
            xpCounterEl.textContent = `${currentXPInLevel}/${xpForNextLevel} XP`;
            xpBarEl.style.width = `${currentXPInLevel}%`;
        }
        function checkUsageLimit() {
            const isLocked = !userData.unlocked && userData.count >= MAX_DAILY_USES;
            limitOverlay.style.display = isLocked ? 'flex' : 'none';
            const controls = [mainInput, sendBtn, voiceBtn, fileInput, ...modeButtons, expandBtn];
            controls.forEach(el => {
                if (el) {
                    el.disabled = isLocked;
                    const targetElement = el.tagName === 'INPUT' && el.type === 'file' ? fileInputLabel : el;
                    if (targetElement) {
                         targetElement.style.opacity = isLocked ? '0.5' : '1'; targetElement.style.cursor = isLocked ? 'not-allowed' : 'pointer';
                    }
                }
            });
            if (isLocked) toggleModeExpand(true);
            return !isLocked;
        }
        function incrementUsageCount() {
            if (!userData.unlocked) {
                userData.count++;
            }
            // Th√™m XP cho m·ªói l·∫ßn s·ª≠ d·ª•ng
            userData.xp += 10;
            saveUserData(); // L∆∞u c·∫£ count v√† xp, c·∫≠p nh·∫≠t UI
            if (!userData.unlocked) checkUsageLimit();
        }
        unlockBtn.addEventListener('click', () => {
            if (passwordInput.value === UNLOCK_PASSWORD) {
                userData.unlocked = true; userData.date = new Date().toDateString(); saveUserData();
                checkUsageLimit();
                passwordMessage.textContent = 'M·ªü kh√≥a th√†nh c√¥ng!'; passwordMessage.className = 'mt-3 text-green-500';
                passwordInput.value = '';
                setTimeout(() => { limitOverlay.style.display = 'none'; passwordMessage.className = 'mt-3 text-red-500 hidden'; }, 1500);
            } else {
                passwordMessage.textContent = 'M·∫≠t kh·∫©u sai.'; passwordMessage.className = 'mt-3 text-red-500';
            }
        });

        // === Logic Intro Screen ===
        function playIntro() {
            introScreen.style.display = 'flex';
            try { introAudio.play().catch(e => {}); } catch(e) {}
            setTimeout(() => {
                introScreen.style.opacity = '0';
                appWrapper.style.opacity = '1';
                setTimeout(() => { introScreen.style.display = 'none'; appWrapper.style.zIndex = 'auto'; document.body.style.overflow = 'auto'; }, 1000);
            }, 6000);
        }

        // === Logic Voice Chat ===
        let conversationMode = false; let silenceTimeout;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        
        if (SpeechRecognition) {
            recognition = new SpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; recognition.lang = 'vi-VN';
            recognition.onresult = (event) => { clearTimeout(silenceTimeout); const transcript = event.results[0][0].transcript; voiceStatus.textContent = `B·∫°n: "${transcript}"`; handleVoiceQuery(transcript, recognition.lang); };
            recognition.onend = () => { isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = 'üé§'; if (conversationMode && !speechSynthesis.speaking) startListening(); else if (!conversationMode) voiceStatus.textContent = "Nh·∫•n Mic ƒë·ªÉ B·∫Øt ƒë·∫ßu N√≥i..."; };
            recognition.onerror = (event) => { console.error("Speech Error:", event.error); voiceStatus.textContent = `L·ªói: ${event.error}`; isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = 'üé§'; if (!conversationMode) setTimeout(() => voiceOverlay.style.display = 'none', 3000); };
        } else { voiceBtn.style.display = 'none'; }
        function startListening() {
             if (!recognition || isRecording) { if(isRecording) recognition.stop(); return; }
             voiceStatus.textContent = "ƒêang Nghe..."; micWave.classList.add('listening'); voiceMicIcon.textContent = 'üî¥'; isRecording = true;
             recognition.lang = languageSelect.value === 'en' ? 'en-US' : (languageSelect.value === 'zh-CN' ? 'zh-CN' : 'vi-VN');
             clearTimeout(silenceTimeout); silenceTimeout = setTimeout(() => { if (isRecording) recognition.stop(); voiceStatus.textContent = "H·∫øt th·ªùi gian ch·ªù."; }, 7000);
             try { recognition.start(); } catch(e) { voiceStatus.textContent = `L·ªói: ${e.message}`; isRecording = false; micWave.classList.remove('listening'); voiceMicIcon.textContent = 'üé§'; }
        }
        function speak(text, lang) { return new Promise(resolve => { if (!speechSynthesis) { resolve(); return; } speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang.includes('-') ? lang : (lang === 'en' ? 'en-US' : (lang === 'zh-CN' ? 'zh-CN' : 'vi-VN')); u.onstart = () => voiceStatus.textContent = "AI ƒêang Ph·∫£n H·ªìi..."; u.onend = () => { voiceStatus.textContent = "Nh·∫•n Mic ƒë·ªÉ B·∫Øt ƒë·∫ßu N√≥i..."; resolve(); }; u.onerror = (e) => { console.error("Speak Error:", e); voiceStatus.textContent = `L·ªói ph√°t √¢m: ${e.error}`; resolve(); }; setTimeout(() => speechSynthesis.speak(u), 100); }); }
        async function handleVoiceQuery(transcript, langCode) {
             voiceStatus.textContent = "AI Processing...";
            try {
                const shortLang = langCode.split('-')[0];
                const systemInstruction = getSystemInstruction(shortLang);
                const responseData = await callApi('/api/chat', { message: transcript, image: null, language: shortLang, systemInstruction: systemInstruction });
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = responseData.response;
                const aiReplyText = tempDiv.textContent || tempDiv.innerText || "";
                if (!aiReplyText || aiReplyText.startsWith('‚ùå')) throw new Error(aiReplyText || "AI response invalid.");
                await speak(aiReplyText, langCode);
            } catch (error) {
                const errorMsg = error.message.includes('HTTP Error') ? "Problem connecting." : error.message.startsWith('‚ùå') ? error.message.substring(2) : "Error processing.";
                await speak(errorMsg, langCode);
            } finally {
                incrementUsageCount(); // TƒÉng XP v√† l∆∞·ª£t d√πng
                if (conversationMode && !speechSynthesis.speaking) startListening();
                else if (!conversationMode) setTimeout(() => voiceOverlay.style.display = 'none', 500);
            }
        }
        voiceBtn.addEventListener('click', () => { if (!checkUsageLimit()) return; if (!recognition) return alert("Not supported."); if (!window.isSecureContext && window.location.protocol !== 'http:') return alert('Requires HTTPS/localhost.'); voiceStatus.textContent = "Nh·∫•n Mic ƒë·ªÉ B·∫Øt ƒë·∫ßu N√≥i..."; micWave.classList.remove('listening'); voiceMicIcon.textContent = 'üé§'; voiceOverlay.style.display = 'flex'; conversationMode = true; startListening(); });
        voiceMicIcon.addEventListener('click', () => { if (isRecording) recognition.stop(); else startListening(); });
        voiceCloseBtn.addEventListener('click', () => { conversationMode = false; if (isRecording) recognition.stop(); speechSynthesis.cancel(); voiceOverlay.style.display = 'none'; });

        // === Flashcard & Mindmap Rendering (ƒê√£ s·ª≠a l·ªói hi·ªÉn th·ªã ngay ƒë√°p √°n v√† l·ªói kh√¥ng v·∫Ω ƒë∆∞·ª£c) ===
        function renderFlashcards(rawText) {
            const cardPairs = rawText.split('\nQ:').filter(c => c.trim()).map(c => {
                if (!c.startsWith('Q:')) c = 'Q:' + c;
                const parts = c.split('\nA:');
                const question = parts[0].replace('Q:', '').trim();
                const answer = parts[1] ? parts[1].trim() : 'No Answer Provided';
                return { question, answer };
            });

            let html = `<div class="flashcard-list grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">`;

            cardPairs.forEach((pair, index) => {
                const cardId = `card-${Date.now()}-${index}-${Math.floor(Math.random() * 1000)}`;
                html += `
                    <div class="flashcard-item bg-gray-700 rounded-lg shadow-lg overflow-hidden border-2 border-gray-600">
                        <div id="${cardId}-q" class="p-4 bg-gray-800 text-white font-bold cursor-pointer hover:bg-gray-700 transition" onclick="
                            const a = document.getElementById('${cardId}-a');
                            const q = document.getElementById('${cardId}-q');
                            if (a.style.display === 'none') {
                                a.style.display = 'block';
                                q.style.backgroundColor = '#1f2937'; // bg-gray-800 on click
                                q.classList.remove('font-bold');
                            } else {
                                a.style.display = 'none';
                                q.style.backgroundColor = '#1f2937'; // bg-gray-800
                                q.classList.add('font-bold');
                            }
                        ">
                            <span class="text-yellow-400">Q:</span> ${pair.question}
                        </div>
                        <div id="${cardId}-a" class="p-4 bg-gray-900 text-yellow-400" style="display:none;">
                            <span class="text-gray-400">A:</span> ${pair.answer}
                        </div>
                    </div>`;
            });

            html += `</div>`;
            return html;
        }

        function renderMindmap(rawText) {
            // Chuy·ªÉn ƒë·ªïi Markdown List sang ƒë·ªãnh d·∫°ng Mindmap c·ªßa Mermaid
            let mindmapText = "mindmap\n";
            const lines = rawText.split('\n');
            let rootNode = null;

            for (const line of lines) {
                const match = line.match(/^(\s*)[\*\-]\s+(.*)$/);
                if (!match) continue;

                const indentLevel = match[1].length / 2; // Gi·∫£ s·ª≠ 2 space/tab cho m·ªói c·∫•p
                const text = match[2].trim().replace(/[\[\]\(\)]/g, ''); // Lo·∫°i b·ªè k√Ω t·ª± xung ƒë·ªôt

                if (indentLevel === 0) {
                    if (!rootNode) {
                        rootNode = text;
                        mindmapText += `  root((${text}))\n`;
                    } else {
                        // X·ª≠ l√Ω n·∫øu c√≥ nhi·ªÅu root (chuy·ªÉn th√†nh nh√°nh l·ªõn)
                        mindmapText += `  ${text}((${text}))\n`;
                    }
                } else if (rootNode) {
                    const indent = '  '.repeat(indentLevel + 1);
                    mindmapText += `${indent}${text}\n`;
                }
            }
            
            // Tr·∫£ v·ªÅ HTML v·ªõi class="mermaid" ƒë·ªÉ th∆∞ vi·ªán t·ª± render
            return `<div class="mermaid text-center p-4" style="background-color: #1a1a1e; border-radius: 8px; border: 1px solid #333; overflow-x: auto; max-width: 100%;">${mindmapText}</div>`;
        }

        function addSummaryActions(bubbleElement, summaryText) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'summary-actions';
            actionsDiv.innerHTML = `
                <button class="summary-btn" data-action="flashcard">T·∫°o Flashcards</button>
                <button class="summary-btn" data-action="mindmap">T·∫°o Mindmap</button>
            `;
            actionsDiv.querySelectorAll('.summary-btn').forEach(button => {
                button.addEventListener('click', async () => {
                    if (!checkUsageLimit()) return;
                    const action = button.dataset.action;
                    const endpoint = action === 'flashcard' ? '/api/generate-flashcards' : '/api/generate-mindmap';
                    button.textContent = 'ƒêang t·∫°o...'; button.disabled = true;
                    const loadingBubble = showLoading();
                    
                    try {
                        const response = await callApi(endpoint, { textToConvert: summaryText });
                        if (response.response.startsWith('‚ùå')) throw new Error(response.response);
                        
                        let finalHtml = '';
                        let saveTag = '';
                        
                        if (action === 'flashcard') {
                            finalHtml = renderFlashcards(response.response);
                            saveTag = `[FLASHCARD_START]${response.response}[FLASHCARD_END]`;
                        } else { // mindmap
                            finalHtml = renderMindmap(response.response);
                            saveTag = `[MINDMAP_START]${response.response}[MINDMAP_END]`;
                        }
                        
                        loadingBubble.querySelector('.bubble').innerHTML = finalHtml;
                        saveMessage(saveTag, 'ai');
                        
                        // Manually re-init Mermaid if mindmap
                        if (action === 'mindmap' && window.mermaid) {
                             setTimeout(() => {
                                 // T·∫Øt t·ª± ƒë·ªông kh·ªüi t·∫°o tr∆∞·ªõc khi g·ªçi init
                                 window.mermaid.contentLoaded();
                                 window.mermaid.init(undefined, loadingBubble.querySelector('.mermaid'));
                             }, 100);
                        }

                        incrementUsageCount(); 
                    } catch (error) {
                        loadingBubble.querySelector('.bubble').innerHTML = `‚ùå L·ªói t·∫°o ${action}: ${error.message}`;
                        saveMessage(loadingBubble.querySelector('.bubble').innerHTML, 'ai');
                    } finally {
                        button.textContent = action === 'flashcard' ? 'T·∫°o Flashcards' : 'T·∫°o Mindmap';
                        button.disabled = false;
                    }
                });
            });
            bubbleElement.appendChild(actionsDiv);
        }

        // === C√° nh√¢n h√≥a AI (ƒê√£ s·ª≠a l·ªói b·ªã ghi ƒë√® vai tr√≤) ===
        function getSystemInstruction(lang) {
            const langName = { 'vi': 'Ti·∫øng Vi·ªát', 'en': 'English', 'zh-CN': 'ÁÆÄ‰Ωì‰∏≠Êñá' }[lang] || 'Ti·∫øng Vi·ªát';
            
            // üìå FIX 3B: G·ª£i √Ω ti·∫øp theo kh√¥ng t·ª± nhi√™n
            let followUpSuggestion = `**At the end of your response, always suggest one logical follow-up topic or question for the user to explore next, enclosed in italics (e.g., *B·∫°n c√≥ mu·ªën xem m·ªôt v√≠ d·ª• kh√°c kh√¥ng?*).**`;


            let baseInstruction = `You are a helpful AI assistant. Respond in **${langName}**. Be concise, use markdown, highlight <mark class="highlight">...</mark>. Analyze image if provided. ${followUpSuggestion}`;

            if (currentChatMode === 'persona' && currentPersonaDesc) {
                // üìå FIX 3A: C·∫£i thi·ªán Nh·∫≠p vai (Inhuman response)
                const personaIntro = "I can become any role in the world. If the user enters a famous person, wife, sister, or historical figure, I will recognize that character and answer all questions in that role.";
                const personaInstruction = `IMPORTANT: You must act as the following character: "${currentPersonaDesc}". Respond CONSISTENTLY in this role to all user input. Respond in **${langName}**. Keep answers concise, use markdown, highlight <mark class="highlight">...</mark>. ${personaIntro}
                **SENSITIVE TOPICS RULE:** If the user asks a sensitive or inappropriate question, do NOT revert to stating you are an AI model. Instead, handle the situation *in character* by deflecting, avoiding, expressing offense, or responding creatively as the persona.
                **At the end, suggest one follow-up question *in character* (e.g., *Ng∆∞∆°i c√≥ mu·ªën h·ªèi th√™m v·ªÅ ƒë·ªãnh lu·∫≠t v·∫°n v·∫≠t h·∫•p d·∫´n kh√¥ng?*).**`;
                baseInstruction = personaInstruction;
            }
            return baseInstruction;
        }
        function setPersona(description) {
            currentPersonaDesc = description.trim();
            localStorage.setItem('ai_pro_persona_desc', currentPersonaDesc);
            const introMessage = `Tuy·ªát v·ªùi! T·ª´ gi·ªù t√¥i s·∫Ω nh·∫≠p vai: **${currentPersonaDesc}**. H√£y h·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨! <br><br> (Ghi ch√∫: T√¥i c√≥ th·ªÉ bi·∫øn th√†nh vai tr√≤ c·ªßa b·∫•t k·ªÉ ng∆∞·ªùi n√†o tr√™n th·∫ø gi·ªõi v√† n·∫øu ng∆∞·ªùi d√πng nh·∫≠p m·ªôt nh√¢n v·∫≠t n·ªïi ti·∫øng, v·ª£, em g√°i hay trong l·ªãch s·ª≠, t√¥i s·∫Ω nh·∫≠n bi·∫øt nh√¢n v·∫≠t ƒë√≥ v√† khi ng∆∞·ªùi d√πng h·ªèi c√°i g√¨, t√¥i c≈©ng s·∫Ω tr·∫£ l·ªùi trong vai tr√≤ ƒë√≥.)
            <br><br>G√µ **!clearpersona** ƒë·ªÉ t√¥i tr·ªü l·∫°i th√†nh tr·ª£ l√Ω AI.
            <br><br>*B·∫°n mu·ªën b·∫Øt ƒë·∫ßu v·ªõi c√¢u h·ªèi g√¨ trong vai tr√≤ n√†y?*`;
            appendMessage(introMessage, 'ai', true); // L∆∞u tin nh·∫Øn n√†y v√†o history
        }

        // --- Core Chat Logic ---
        function saveHistoryToStorage() { localStorage.setItem('ai_chat_history_v3', JSON.stringify(chatHistory)); }
        function loadHistoryFromStorage() { chatHistory = JSON.parse(localStorage.getItem('ai_chat_history_v3')) || {}; }

        function appendMessage(content, type, save = true) {
             const messageGroup = document.createElement('div'); messageGroup.className = `message-group ${type}`;
             const avatar = document.createElement('div'); avatar.className = `avatar avatar-${type}`; avatar.innerHTML = type === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-robot"></i>'; // D√πng icon
             const bubble = document.createElement('div'); bubble.className = 'bubble';
             bubble.innerHTML = content.replace(/\n/g, '<br>'); // Hi·ªÉn th·ªã xu·ªëng d√≤ng
             messageGroup.appendChild(avatar); messageGroup.appendChild(bubble); chatBox.appendChild(messageGroup);
             setTimeout(() => chatBox.scrollTop = chatBox.scrollHeight, 50);
             if (save) saveMessage(content, type);
             return messageGroup;
        }
        function saveMessage(content, type) {
            if (!activeChatId || !chatHistory[activeChatId]) return;
            if (!Array.isArray(chatHistory[activeChatId].messages)) chatHistory[activeChatId].messages = [];
            chatHistory[activeChatId].messages.push({ content, type, timestamp: Date.now() });
            saveHistoryToStorage();
        }
        function displayWelcomeMessage() {
            chatBox.innerHTML = `<div class="welcome-message"><h2>AI Assistant Pro ü§ñ</h2><p class="mt-4">How can I help you today?</p><p class="mt-2 text-sm text-gray-500">(S·ª≠ d·ª•ng n√∫t <span class="text-yellow-500 font-bold">+</span> ƒë·ªÉ kh√°m ph√° c√°c ch·ª©c nƒÉng...)</p></div>`;
        }
        function startNewChat() {
            // üìå FIX 2: Reset Persona khi t·∫°o chat m·ªõi
            currentPersonaDesc = ''; 
            localStorage.removeItem('ai_pro_persona_desc');
            
            activeChatId = `chat_${Date.now()}`;
            chatHistory[activeChatId] = { title: 'New Conversation', messages: [] };
            displayWelcomeMessage();
            renderChatHistory();
            saveHistoryToStorage();
            handleModeSelection('chat'); // Quay v·ªÅ ch·∫ø ƒë·ªô chat m·∫∑c ƒë·ªãnh
        }
        function loadChat(chatId) {
            if (!chatHistory[chatId]) return startNewChat();
            activeChatId = chatId; chatBox.innerHTML = '';
            const messages = chatHistory[activeChatId].messages || [];
            if (messages.length === 0) displayWelcomeMessage();
            else messages.forEach(msg => {
                let content = msg.content;
                let isFlashcard = false;
                let isMindmap = false;
                
                // 1. Check for Flashcard History
                if (content.startsWith('[FLASHCARD_START]') && content.endsWith('[FLASHCARD_END]')) {
                    const rawText = content.substring('[FLASHCARD_START]'.length, content.length - '[FLASHCARD_END]'.length);
                    content = renderFlashcards(rawText);
                    isFlashcard = true;
                }
                
                // 2. Check for Mindmap History
                else if (content.startsWith('[MINDMAP_START]') && content.endsWith('[MINDMAP_END]')) {
                    const rawText = content.substring('[MINDMAP_START]'.length, content.length - '[MINDMAP_END]'.length);
                    content = renderMindmap(rawText);
                    isMindmap = true;
                }

                const msgGroup = appendMessage(content, msg.type, false);
                
                // 3. Th√™m l·∫°i n√∫t action n·∫øu l√† summary (v√† ch∆∞a chuy·ªÉn ƒë·ªïi)
                const isSummary = msg.type === 'ai' && (msg.content.includes("key points") || msg.content.includes("## Key Points") || msg.content.includes("T√≥m t·∫Øt") || msg.content.includes("Marketing"));
                if (isSummary && !msg.content.startsWith('‚ùå') && !isFlashcard && !isMindmap) {
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = msg.content;
                    const summaryText = tempDiv.textContent || tempDiv.innerText || "";
                    addSummaryActions(msgGroup.querySelector('.bubble'), summaryText);
                }
            });
            
            // Re-render Mermaid sau khi t·∫£i l·ªãch s·ª≠
            setTimeout(() => {
                if (window.mermaid) {
                    window.mermaid.contentLoaded();
                    window.mermaid.init(undefined, document.querySelectorAll('.mermaid'));
                }
            }, 50);

            renderChatHistory();
            // Kh√¥ng chuy·ªÉn mode khi load chat ƒë·ªÉ gi·ªØ l·∫°i mode hi·ªán t·∫°i n·∫øu l√† persona/stock
            // handleModeSelection('chat'); 
        }
         function renderChatHistory() {
             chatHistoryContainer.innerHTML = '';
             const sortedKeys = Object.keys(chatHistory).sort((a, b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]));
             sortedKeys.forEach(key => {
                 const chat = chatHistory[key];
                 if (chat && chat.title) {
                     const item = document.createElement('div');
                     item.className = `history-item ${key === activeChatId ? 'active' : ''}`;
                     item.dataset.chatId = key;
                     item.textContent = chat.title;
                     item.addEventListener('click', () => { loadChat(key); sidebar.classList.remove('open'); });
                     chatHistoryContainer.appendChild(item);
                 }
             });
             if (chatHistoryContainer.innerHTML === '') {
                  chatHistoryContainer.innerHTML = '<div class="text-center text-gray-500 mt-4">No history.</div>';
             }
         }
        function updateChatTitle(firstUserMessage, isImageOnly = false) {
             if (!activeChatId || !chatHistory[activeChatId]) return;
             if (chatHistory[activeChatId].title === 'New Conversation') {
                 let newTitle = "Untitled";
                 if (firstUserMessage) newTitle = firstUserMessage.substring(0, 30) + (firstUserMessage.length > 30 ? '...' : '');
                 else if (isImageOnly) newTitle = "Image Input";
                 chatHistory[activeChatId].title = newTitle;
                 saveHistoryToStorage();
                 renderChatHistory();
             }
        }
        function showLoading() {
            const loadingMessage = document.createElement('div');
            loadingMessage.className = 'message-group ai';
            loadingMessage.id = 'loading-indicator';
            loadingMessage.innerHTML = `<div class="avatar avatar-ai">ü§ñ</div><div class="bubble"><div class="typing-indicator"><span></span><span></span><span></span></div></div>`;
            chatBox.appendChild(loadingMessage);
            setTimeout(() => chatBox.scrollTop = chatBox.scrollHeight, 50);
            return loadingMessage;
        }
        async function callApi(endpoint, body) {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });
            const responseBody = await response.text();
            if (!response.ok) {
                 try { const errorJson = JSON.parse(responseBody); throw new Error(errorJson.response || errorJson.message || `Server error ${response.status}`); }
                 catch (e) { throw new Error(responseBody || `Server error ${response.status}`); }
            }
            try { return JSON.parse(responseBody); }
            catch (e) { throw new Error("Invalid JSON response from server."); }
        }
        function createGifFromFrames(frames) {
             return new Promise((resolve, reject) => {
                 if (!frames || frames.length === 0) return reject(new Error("No frames provided to create GIF."));
                 const gif = new GIF({ workers: 2, quality: 10, width: 512, height: 512, workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js' });
                 const imagePromises = frames.map(frameData => new Promise(resolveImg => {
                     const img = new Image(); img.crossOrigin = "anonymous";
                     img.src = frameData;
                     img.onload = () => resolveImg(img);
                     img.onerror = () => { console.warn("Failed to load a frame"); resolveImg(null); };
                 }));
                 Promise.all(imagePromises).then(imageElements => {
                     const validImages = imageElements.filter(img => img);
                     if (validImages.length === 0) return reject(new Error("Could not load any valid frames."));
                     validImages.forEach(img => gif.addFrame(img, { delay: 100 }));
                     gif.on('finished', (blob) => resolve(URL.createObjectURL(blob)));
                     gif.render();
                 }).catch(reject);
             });
        }

        // === Logic Mode Selector M·ªõi ===
        function toggleModeExpand(forceClose = false) {
            isModeExpanded = forceClose ? false : !isModeExpanded;
            if (isModeExpanded) {
                hiddenModesContainer.classList.add('open');
                expandBtn.querySelector('#expand-icon').textContent = '‚Äî';
            } else {
                hiddenModesContainer.classList.remove('open');
                expandBtn.querySelector('#expand-icon').textContent = '+';
            }
        }
        expandBtn.addEventListener('click', (e) => { e.preventDefault(); toggleModeExpand(); });
        function handleModeSelection(selectedMode) {
             const previousMode = currentChatMode;
             modeButtons.forEach(btn => btn.classList.remove('active'));
             const newActiveBtn = document.querySelector(`.mode-btn[data-mode="${selectedMode}"]`);
             if (newActiveBtn) newActiveBtn.classList.add('active');
             else document.querySelector(`.mode-btn[data-mode="chat"]`)?.classList.add('active');
             if (selectedMode !== 'chat' && isModeExpanded) toggleModeExpand(true);
             currentChatMode = selectedMode;

             switch(currentChatMode) {
                 case 'persona':
                     mainInput.placeholder = currentPersonaDesc ? `Chatting as ${currentPersonaDesc} (g√µ !clearpersona ƒë·ªÉ reset)...` : 'Nh·∫≠p vai tr√≤ b·∫°n mu·ªën t√¥i ƒë√≥ng (vd: Einstein)...';
                     if ((previousMode !== 'persona' || !currentPersonaDesc) && activeChatId) {
                         const lastMsg = chatHistory[activeChatId]?.messages.slice(-1)[0];
                         if (!lastMsg || !lastMsg.content.includes("N√†o, h√£y cho t√¥i bi·∫øt")) {
                            if (document.querySelector('.welcome-message')) document.querySelector('.welcome-message').remove();
                            appendMessage("N√†o, h√£y cho t√¥i bi·∫øt b·∫°n mu·ªën t√¥i tr·ªü th√†nh ai! (vd: 'Albert Einstein', 'chuy√™n gia marketing', 'em g√°i c·ªßa t√¥i')...", 'ai', false);
                         }
                     }
                     break;
                 case 'summarize_youtube': mainInput.placeholder = 'D√°n URL video YouTube (k√®m ID video)...'; break;
                 case 'analyze_stock': mainInput.placeholder = 'Nh·∫≠p m√£ ch·ª©ng kho√°n (vd: AAPL, VNM)...'; break;
                 case 'edit_image': mainInput.placeholder = 'T·∫£i ·∫£nh & m√¥ t·∫£ ch·ªânh s·ª≠a (vd: "bi·∫øn anh ·∫•y th√†nh ng∆∞·ªùi m√°y")...'; break;
                 case 'notetaker': mainInput.placeholder = 'D√°n vƒÉn b·∫£n c·∫ßn ghi ch√∫...'; break;
                 case 'marketing': mainInput.placeholder = 'Nh·∫≠p ch·ªß ƒë·ªÅ/s·∫£n ph·∫©m c·∫ßn vi·∫øt content...'; break;
                 case 'music': mainInput.placeholder = 'Nh·∫≠p ch·ªß ƒë·ªÅ/t√¢m tr·∫°ng cho b√†i nh·∫°c (Ch·ªâ t·∫°o l·ªùi & h·ª£p √¢m, kh√¥ng t·∫°o √¢m thanh)...'; break;
                 default: mainInput.placeholder = 'H·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨...';
             }
             const fileLabel = fileInput.labels[0];
             const allowFile = ['chat', 'math', 'edit_image', 'persona'].includes(currentChatMode);
             if (fileLabel) fileLabel.style.display = allowFile ? 'flex' : 'none';
             if (!allowFile) { uploadedFile = null; previewContainer.innerHTML = ''; fileInput.value = ''; }
        }
        modeButtons.forEach(button => { button.addEventListener('click', () => { if (!button.disabled) handleModeSelection(button.dataset.mode); }); });

        // --- Main Send Function ---
        const handleSendMessage = async () => {
             if (!checkUsageLimit()) return;
             const prompt = mainInput.value.trim(); const image = uploadedFile;
             
             // üìå FIX 1: Th√™m l·ªánh x√≥a vai tr√≤ (clear persona)
             if (currentChatMode === 'persona' && currentPersonaDesc && prompt.toLowerCase().includes('!clearpersona')) {
                 currentPersonaDesc = '';
                 localStorage.removeItem('ai_pro_persona_desc');
                 appendMessage("ƒê√£ x√≥a vai tr√≤ nh·∫≠p vai. T√¥i ƒë√£ tr·ªü l·∫°i th√†nh tr·ª£ l√Ω AI th√¥ng th∆∞·ªùng.", 'ai', true);
                 mainInput.value = '';
                 mainInput.placeholder = 'Nh·∫≠p vai tr√≤ b·∫°n mu·ªën t√¥i ƒë√≥ng (vd: Einstein)...';
                 return;
             }

             if (currentChatMode === 'persona' && !currentPersonaDesc) {
                  if (!prompt) { alert("Vui l√≤ng nh·∫≠p vai tr√≤."); return; }
                  setPersona(prompt); mainInput.value = ''; mainInput.placeholder = `Chatting as ${currentPersonaDesc} (g√µ !clearpersona ƒë·ªÉ reset)...`; return;
             }
             if (currentChatMode === 'edit_image' && !image) { alert("Vui l√≤ng t·∫£i ·∫£nh."); return; }
             if (!prompt && currentChatMode === 'analyze_stock') { alert("Vui l√≤ng nh·∫≠p m√£ ch·ª©ng kho√°n."); return; }
             if (!prompt && currentChatMode === 'summarize_youtube') { alert("Vui l√≤ng d√°n URL YouTube."); return; }
             if (!prompt && currentChatMode === 'notetaker') { alert("Vui l√≤ng d√°n vƒÉn b·∫£n."); return; }
             if (!prompt && currentChatMode === 'marketing') { alert("Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ marketing."); return; }
             if (!prompt && currentChatMode === 'music') { alert("Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ cho b√†i nh·∫°c."); return; }
             if (!prompt && !image && !['chat', 'math', 'persona'].includes(currentChatMode)) { return; }

             if (document.querySelector('.welcome-message')) document.querySelector('.welcome-message').remove();
             let userMsgContent = prompt;
             if (image && ['chat', 'math', 'edit_image', 'persona'].includes(currentChatMode)) {
                 userMsgContent = `<img src="${image}" style="max-height:100px; border-radius:8px; margin-bottom:5px; display:block;" alt="uploaded"><p>${prompt || 'Analyze/Edit'}</p>`;
             }
             appendMessage(userMsgContent || (image ? "[Image]" : "[Empty]"), 'user');
             updateChatTitle(prompt, !prompt && !!image);
             const loadingBubbleGroup = showLoading();
             const currentPromptValue = prompt; const currentImageValue = image;
             mainInput.value = ''; previewContainer.innerHTML = ''; uploadedFile = null; fileInput.value = ''; mainInput.style.height = 'auto';

            try {
                let responseData; let finalContent = ''; let isSummaryResult = false;
                let systemInstruction = getSystemInstruction(languageSelect.value);

                switch (currentChatMode) {
                    case 'image': responseData = await callApi('/api/pollinations-image', { prompt: currentPromptValue }); finalContent = `<img src="${responseData.imageUrl}" class="generated-image">`; break;
                    case 'edit_image':
                        // üìå FIX 4: S·ª≠a ·∫£nh (Image Editing) - ƒê·∫£m b·∫£o h√¨nh ·∫£nh ƒë∆∞·ª£c tr·∫£ v·ªÅ
                        loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating edit description...';
                        // System instruction c·ª©ng ƒë·ªÉ ƒë·∫£m b·∫£o prompt ƒë·∫ßu ra l√† text ti·∫øng Anh thu·∫ßn
                        const editImageInstruction = `Analyze the uploaded image and the user's text description. Your task is to generate ONLY the best, most detailed English prompt (max 30 words) for a powerful text-to-image model (like Midjourney or DALL-E) to create the *edited* image. DO NOT add any surrounding text, just the prompt.`;
                        
                        const descRes = await callApi('/api/edit-image', { message: currentPromptValue, image: currentImageValue, systemInstruction: editImageInstruction });
                        const newPrompt = descRes.response; 
                        
                        if (newPrompt.startsWith('‚ùå')) throw new Error(newPrompt);
                        
                        loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating edited image...';
                        const imgRes = await callApi('/api/pollinations-image', { prompt: newPrompt });

                        // Ki·ªÉm tra l·∫°i URL h√¨nh ·∫£nh tr∆∞·ªõc khi hi·ªÉn th·ªã
                        if (!imgRes.imageUrl || imgRes.imageUrl.includes('Could not create image')) {
                            throw new Error("Image generation failed or returned an invalid URL.");
                        }

                        // X√¢y d·ª±ng finalContent v·ªõi c·∫£ prompt v√† h√¨nh ·∫£nh
                        finalContent = `<p><strong>Based on:</strong> <mark class="highlight">${newPrompt}</mark></p><img src="${imgRes.imageUrl}" class="generated-image">`;
                        
                        break;
                    case 'math': systemInstruction = `Solve math in Vietnamese...`; responseData = await callApi('/api/math', { question: currentPromptValue, image: currentImageValue, systemInstruction }); finalContent = responseData.response; break;
                    case 'summarize_youtube': responseData = await callApi('/api/summarize-youtube', { youtubeUrl: currentPromptValue }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'notetaker': systemInstruction = "You are a notetaker..."; responseData = await callApi('/api/summarize-text', { textToSummarize: currentPromptValue, systemInstruction }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'analyze_stock': responseData = await callApi('/api/analyze-stock', { stockSymbol: currentPromptValue }); finalContent = responseData.response; break;
                    case 'marketing': responseData = await callApi('/api/marketing-content', { marketingTopic: currentPromptValue, language: languageSelect.value }); finalContent = responseData.response; isSummaryResult = true; break;
                    case 'music': responseData = await callApi('/api/music-generation', { musicTopic: currentPromptValue, language: languageSelect.value }); 
                        // FIX 1: Nh·∫°c (Gi·∫£i th√≠ch gi·ªõi h·∫°n)
                        finalContent = `**Ghi ch√∫:** Gemini AI ch·ªâ c√≥ th·ªÉ t·∫°o l·ªùi v√† h·ª£p √¢m, kh√¥ng th·ªÉ t·∫°o ra file √¢m thanh.\n\n${responseData.response}`; 
                        break;
                    case 'video':
                         loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Generating frames...';
                         responseData = await callApi('/api/pollinations-frames', { prompt: currentPromptValue });
                         if (!responseData.frames || !Array.isArray(responseData.frames) || responseData.frames.length === 0) { throw new Error(responseData.message || 'Video frame gen failed.'); }
                         loadingBubbleGroup.querySelector('.bubble').innerHTML = 'Rendering GIF...';
                         const videoUrl = await createGifFromFrames(responseData.frames);
                         finalContent = `<img src="${videoUrl}" class="generated-video">`; break;
                    case 'persona': case 'chat':
                         responseData = await callApi('/api/chat', { message: currentPromptValue, image: currentImageValue, language: languageSelect.value, systemInstruction: systemInstruction });
                         finalContent = responseData.response; break;
                }

                const aiBubbleElement = loadingBubbleGroup.querySelector('.bubble');
                
                // L∆∞u n·ªôi dung th√¥ ho·∫∑c HTML t√πy theo ch·∫ø ƒë·ªô
                if (isSummaryResult && !finalContent.startsWith('‚ùå')) {
                    // X·ª≠ l√Ω n·ªôi dung t√≥m t·∫Øt ƒë·ªÉ th√™m n√∫t h√†nh ƒë·ªông
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = finalContent;
                    const summaryText = tempDiv.textContent || tempDiv.innerText || "";
                    
                    aiBubbleElement.innerHTML = finalContent;
                    addSummaryActions(aiBubbleElement, summaryText);
                    saveMessage(finalContent, 'ai');

                } else if (currentChatMode === 'math') { 
                    // X·ª≠ l√Ω MathJax
                    aiBubbleElement.innerHTML = finalContent;
                    MathJax.typesetPromise([aiBubbleElement]); 
                    saveMessage(finalContent, 'ai');
                    
                } else {
                    // N·ªôi dung th∆∞·ªùng, ch·ªâ g√°n v√† l∆∞u
                    aiBubbleElement.innerHTML = finalContent;
                    saveMessage(finalContent, 'ai');
                }
                
                incrementUsageCount(); // TƒÉng XP v√† l∆∞·ª£t d√πng

            } catch (error) {
                loadingBubbleGroup.querySelector('.bubble').innerHTML = `‚ùå Error: ${error.message}`;
                saveMessage(loadingBubbleGroup.querySelector('.bubble').innerHTML, 'ai');
            }
        };

        // --- Event Listeners and Initializers ---
        sendBtn.addEventListener('click', handleSendMessage);
        newChatBtn.addEventListener('click', startNewChat);
        menuBtn.addEventListener('click', () => { sidebar.classList.toggle('open'); });
        settingsBtn.addEventListener('click', () => { settingsModal.style.display = settingsModal.style.display === 'block' ? 'none' : 'block'; });
        document.addEventListener('click', (e) => {
             if (sidebar.classList.contains('open') && !sidebar.contains(e.target) && !menuBtn.contains(e.target)) { sidebar.classList.remove('open'); }
             if (settingsModal.style.display === 'block' && !settingsBtn.contains(e.target) && !settingsModal.contains(e.target)) { settingsModal.style.display = 'none'; }
        });
        mainInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
        mainInput.addEventListener('input', () => { mainInput.style.height = 'auto'; mainInput.style.height = (mainInput.scrollHeight) + 'px'; });
        fileInput.addEventListener('change', (event) => {
             const file = event.target.files[0];
             if (file) {
                 if (file.size > 5 * 1024 * 1024) { alert("File size exceeds 5MB limit."); fileInput.value = ''; return; }
                 const reader = new FileReader();
                 reader.onload = (e) => { uploadedFile = e.target.result; previewContainer.innerHTML = `<img src="${uploadedFile}" alt="Preview" class="rounded-lg shadow">`; };
                 reader.readAsDataURL(file);
             }
         });

        function initializeApp() {
            playIntro(); // B·∫≠t l·∫°i Intro
            loadHistoryFromStorage();
            if (Object.keys(chatHistory).length === 0) startNewChat();
            else loadChat(Object.keys(chatHistory).sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]))[0] || Object.keys(chatHistory)[0]);
            renderChatHistory();
            loadUserData(); // Load gi·ªõi h·∫°n v√† gamification
            const savedLang = localStorage.getItem('chat_language') || 'vi';
            languageSelect.value = savedLang;
            handleModeSelection('chat');
        }
        initializeApp();
    });
    </script>
</body>
</html>